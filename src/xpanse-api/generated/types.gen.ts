/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: Huawei Inc.
 */

// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
    baseUrl: 'http://localhost:8080' | (string & {});
};

export type ErrorResponse = {
    /**
     * The result code of response.
     */
    errorType: ErrorType;
    /**
     * Details of the errors occurred
     */
    details: Array<string>;
};

export enum ErrorType {
    RUNTIME_ERROR = 'Runtime Error',
    PARAMETERS_INVALID = 'Parameters Invalid',
    TERRAFORM_SCRIPT_INVALID = 'Terraform Script Invalid',
    UNPROCESSABLE_ENTITY = 'Unprocessable Entity',
    RESPONSE_NOT_VALID = 'Response Not Valid',
    FAILURE_WHILE_CONNECTING_TO_BACKEND = 'Failure while connecting to backend',
    CREDENTIAL_CAPABILITY_NOT_FOUND = 'Credential Capability Not Found',
    CREDENTIALS_NOT_FOUND = 'Credentials Not Found',
    CREDENTIAL_VARIABLES_NOT_COMPLETE = 'Credential Variables Not Complete',
    FLAVOR_INVALID = 'Flavor Invalid',
    TERRAFORM_EXECUTION_FAILED = 'Terraform Execution Failed',
    PLUGIN_NOT_FOUND = 'Plugin Not Found',
    DEPLOYER_NOT_FOUND = 'Deployer Not Found',
    NO_CREDENTIAL_DEFINITION_AVAILABLE = 'No Credential Definition Available',
    INVALID_SERVICE_STATE = 'Invalid Service State',
    INVALID_SERVICE_DEPLOYMENT_STATE = 'Invalid Service Deployment State',
    RESOURCE_INVALID_FOR_MONITORING = 'Resource Invalid For Monitoring',
    UNHANDLED_EXCEPTION = 'Unhandled Exception',
    ICON_PROCESSING_FAILED = 'Icon Processing Failed',
    SERVICE_TEMPLATE_NOT_REGISTERED = 'Service Template Not Registered',
    SERVICE_TEMPLATE_UNAVAILABLE = 'Service Template Unavailable',
    SERVICE_TEMPLATE_REQUEST_NOT_ALLOWED = 'Service Template Request Not Allowed',
    SERVICE_TEMPLATE_REQUEST_NOT_FOUND = 'Service Template Request Not Found',
    REVIEW_SERVICE_TEMPLATE_REQUEST_NOT_ALLOWED = 'Review Service Template Request Not Allowed',
    INVALID_SERVICE_VERSION = 'Invalid Service Version',
    INVALID_SERVICE_FLAVORS = 'Invalid Service Flavors',
    MANDATORY_VALUE_MISSING = 'Mandatory Value Missing',
    INVALID_BILLING_CONFIG = 'Invalid Billing Config',
    UNAVAILABLE_SERVICE_REGIONS = 'Unavailable Service Regions',
    SERVICE_DEPLOYMENT_NOT_FOUND = 'Service Deployment Not Found',
    RESOURCE_NOT_FOUND = 'Resource Not Found',
    DEPLOYMENT_VARIABLE_INVALID = 'Deployment Variable Invalid',
    UNAUTHORIZED = 'Unauthorized',
    ACCESS_DENIED = 'Access Denied',
    SENSITIVE_FIELD_ENCRYPTION_OR_DECRYPTION_FAILED_EXCEPTION = 'Sensitive Field Encryption Or Decryption Failed Exception',
    UNSUPPORTED_ENUM_VALUE = 'Unsupported Enum Value',
    TERRA_BOOT_REQUEST_FAILED = 'Terra Boot Request Failed',
    TOFU_MAKER_REQUEST_FAILED = 'Tofu Maker Request Failed',
    METRICS_DATA_NOT_READY = 'Metrics Data Not Ready',
    VARIABLE_VALIDATION_FAILED = 'Variable Validation Failed',
    VARIABLE_SCHEMA_DEFINITION_INVALID = 'Variable Schema Definition Invalid',
    POLICY_NOT_FOUND = 'Policy Not Found',
    DUPLICATE_POLICY = 'Duplicate Policy',
    POLICY_VALIDATION_FAILED = 'Policy Validation Failed',
    POLICY_EVALUATION_FAILED = 'Policy Evaluation Failed',
    CURRENT_LOGIN_USER_NO_FOUND = 'Current Login User No Found',
    SERVICE_DETAILS_NO_ACCESSIBLE = 'Service Details No Accessible',
    SERVICE_PORTING_ACTIVITI_TASK_NOT_FOUND = 'Service Porting Activiti Task Not Found',
    SERVICE_PORTING_FAILED_EXCEPTION = 'Service Porting Failed Exception',
    SERVICE_PORTING_NOT_FOUND = 'Service Porting Not Found',
    SERVICE_LOCKED = 'Service Locked',
    EULA_NOT_ACCEPTED = 'Eula Not Accepted',
    SERVICE_FLAVOR_DOWNGRADE_NOT_ALLOWED = 'Service Flavor Downgrade Not Allowed',
    BILLING_MODE_NOT_SUPPORTED = 'Billing Mode Not Supported',
    SERVICE_STATE_MANAGEMENT_TASK_NOT_FOUND = 'Service State Management Task Not Found',
    SERVICE_ORDER_NOT_FOUND = 'Service Order Not Found',
    SERVICE_PRICE_CALCULATION_FAILED = 'Service Price Calculation Failed',
    INVALID_GIT_REPO_DETAILS = 'Invalid Git Repo Details',
    FILE_LOCKED = 'File Locked',
    SERVICE_CONFIGURATION_INVALID = 'Service Configuration Invalid',
    SERVICE_CONFIGURATION_UPDATE_REQUEST_NOT_FOUND = 'Service Configuration Update Request Not Found',
    SERVICE_CONFIGURATION_NOT_FOUND = 'Service Configuration Not Found',
    INVALID_DEPLOYER_TOOL = 'Invalid Deployer Tool',
    DEPLOYMENT_SCRIPTS_CREATION_FAILED = 'Deployment Scripts Creation Failed',
    ASYNC_START_SERVICE_ERROR = 'Async Start Service Error',
    ASYNC_STOP_SERVICE_ERROR = 'Async Stop Service Error',
    ASYNC_RESTART_SERVICE_ERROR = 'Async Restart Service Error',
    DEPLOYMENT_FAILED_EXCEPTION = 'Deployment Failed Exception',
    DESTROY_FAILED_EXCEPTION = 'Destroy Failed Exception',
    SERVICE_ACTION_INVALID = 'Service Action Invalid',
    SERVICE_CHANGE_REQUEST_FAILED = 'Service Change Request Failed',
    SERVICE_CONFIGURATION_CHANGE_ORDER_ALREADY_EXISTS = 'Service Configuration Change Order Already Exists',
    SERVICE_ACTION_CHANGE_ORDER_ALREADY_EXISTS = 'Service Action Change Order Already Exists',
    INVALID_SERVICE_OBJECT_REQUEST = 'Invalid Service Object Request',
    SERVICE_OBJECT_NOT_FOUND = 'Service Object Not Found',
    SERVICE_OBJECT_CHANGE_ORDER_ALREADY_EXISTS = 'Service Object Change Order Already Exists',
}

export type CreateCredential = {
    /**
     * The name of the credential
     */
    name: string;
    /**
     * The cloud service provider of the credential.
     */
    csp: Csp;
    /**
     * The site to which the credentials belong to.
     */
    site: string;
    /**
     * The description of the credential
     */
    description?: string;
    /**
     * The type of the credential
     */
    type: CredentialType;
    /**
     * The variables list of the credential. The list elements must be unique.
     */
    variables: Array<CredentialVariable>;
    /**
     * The time in seconds to live of the credential
     */
    timeToLive: number;
};

export enum CredentialType {
    VARIABLES = 'variables',
    HTTP_AUTHENTICATION = 'http_authentication',
    API_KEY = 'api_key',
    OAUTH2 = 'oauth2',
}

export type CredentialVariable = {
    /**
     * The name of the CredentialVariable,this field is provided by the plugin of cloud service provider.
     */
    name: string;
    /**
     * The description of the CredentialVariable,this field is provided by the plugin of cloud service provider.
     */
    description: string;
    /**
     * If the variable is mandatory. If is optional then the credential completeness check will ignore this variable. It is upto the plugin to decide what needs to be done if this optional credential variable is present.
     */
    isMandatory?: boolean;
    /**
     * Defines if the particular variable contains sensitive data. For example the value is false for username and true for password variables respectively.
     */
    isSensitive: boolean;
    /**
     * The value of the CredentialVariable, this field is filled by the user.
     */
    value: string;
};

export enum Csp {
    HUAWEI_CLOUD = 'HuaweiCloud',
    FLEXIBLE_ENGINE = 'FlexibleEngine',
    OPENSTACK_TESTLAB = 'OpenstackTestlab',
    PLUS_SERVER = 'PlusServer',
    REGIO_CLOUD = 'RegioCloud',
    ALIBABA_CLOUD = 'AlibabaCloud',
    AWS = 'aws',
    AZURE = 'azure',
    GOOGLE_CLOUD_PLATFORM = 'GoogleCloudPlatform',
}

export type ServiceOrder = {
    /**
     * The id of the service order.
     */
    orderId: string;
    /**
     * The id of the deployed service.
     */
    serviceId: string;
};

export type ServiceObjectRequest = {
    /**
     * The name of service object identifier.
     */
    objectIdentifier: string;
    /**
     * The collection of dependent object IDs.
     */
    linkedObjects?: Array<string>;
    /**
     * The collection of service object parameter.
     */
    serviceObjectParameters: {
        [key: string]: unknown;
    };
};

export type ModifyRequest = {
    /**
     * Customer's name for the service. Used only for customer's reference. If not provided, the existing customerServiceName from the service will be reused.
     */
    customerServiceName?: string;
    /**
     * The flavor of the Service.
     */
    flavor?: string;
    /**
     * The properties for the requested service
     */
    serviceRequestProperties?: {
        [key: string]: unknown;
    };
};

export type OrderFailedErrorResponse = {
    /**
     * The result code of response.
     */
    errorType: ErrorType;
    /**
     * Details of the errors occurred
     */
    details: Array<string>;
    /**
     * The service id associated with the request.
     */
    serviceId?: string;
    /**
     * The order id associated with the request.
     */
    orderId?: string;
};

export type ServiceConfigurationUpdate = {
    /**
     * The service configuration to be modified
     */
    configuration: {
        [key: string]: unknown;
    };
};

export type ServiceLockConfig = {
    modifyLocked?: boolean;
    destroyLocked?: boolean;
};

export type ServiceActionRequest = {
    /**
     * The name service action.
     */
    actionName: string;
    /**
     * The service actions parameter to be modified
     */
    actionParameters: {
        [key: string]: unknown;
    };
};

export type AnsibleScriptConfig = {
    /**
     * name of the ansible playbook. Should be the fully qualified file name (including the directory path) in the repo.
     */
    playbookName: string;
    /**
     * Path where the virtualenv must be created.
     */
    virtualEnv: string;
    /**
     * Version of the python. This version of python must be available in node which is acting as the configManager.
     */
    pythonVersion: string;
    /**
     * The agent will prepare the virtual environment if this true.Otherwise it is assumed that the environment is already prepared as part of the resource creation or the VM base image build.
     */
    isPrepareAnsibleEnvironment: boolean;
    /**
     * Url of the script repo.
     */
    repoUrl: string;
    /**
     * Branch of the git repo.
     */
    branch: string;
    /**
     * the python module requirements file in GIT repo. Should be the fully qualified file name (including the directory path).
     */
    requirementsFile: string;
    /**
     * Full path of the roles and collections requirements file in GIT repo.
     */
    galaxyFile: string;
    /**
     * Defines if the complete service inventory is necessary for running the ansible job.
     */
    ansibleInventoryRequired?: boolean;
};

export type AutoFill = {
    /**
     * Type of the cloud resource to be reused.
     */
    deployResourceKind: DeployResourceKind;
    /**
     *  defines if the required cloud resource can be newly created or should the existing resources must only be used.
     */
    isAllowCreate: boolean;
};

export type AvailabilityZoneConfig = {
    /**
     * The display name of availability zone.
     */
    displayName: string;
    /**
     * The variable name of availability zone.
     */
    varName: string;
    /**
     * Indicates if the variable is mandatory.
     */
    mandatory: boolean;
    /**
     * The description of availability zone.
     */
    description?: string;
};

export type Billing = {
    /**
     * Supported billing modes by the managed service. The list elements must be unique.
     */
    billingModes: Array<BillingMode>;
    /**
     *  This is used only for display purposes. When provided, this billingMode will be selected in the frontends by default.
     */
    defaultBillingMode?: BillingMode;
};

export enum BillingMode {
    FIXED = 'Fixed',
    PAY_PER_USE = 'Pay per Use',
}

export enum Category {
    AI = 'ai',
    COMPUTE = 'compute',
    CONTAINER = 'container',
    STORAGE = 'storage',
    NETWORK = 'network',
    DATABASE = 'database',
    MEDIA_SERVICE = 'mediaService',
    SECURITY = 'security',
    MIDDLEWARE = 'middleware',
    OTHERS = 'others',
}

export type CloudServiceProvider = {
    /**
     * The Cloud Service Provider.
     */
    name: Csp;
    /**
     * The regions of the Cloud Service Provider. The list elements must be unique.
     */
    regions: Array<Region>;
};

export enum ConfigurationManagerTool {
    ANSIBLE = 'ansible',
}

export enum Currency {
    USD = 'USD',
    EUR = 'EUR',
    CNY = 'CNY',
}

export enum DeployResourceKind {
    VM = 'vm',
    RDS = 'rds',
    CONTAINER = 'container',
    PUBLIC_IP = 'publicIP',
    VPC = 'vpc',
    VOLUME = 'volume',
    UNKNOWN = 'unknown',
    SECURITY_GROUP = 'security_group',
    SECURITY_GROUP_RULE = 'security_group_rule',
    KEYPAIR = 'keypair',
    SUBNET = 'subnet',
}

export enum DeployerKind {
    TERRAFORM = 'terraform',
    OPENTOFU = 'opentofu',
    HELM = 'helm',
}

export type DeployerTool = {
    /**
     * The type of the deployer which will handle the service deployment.
     */
    kind: DeployerKind;
    /**
     * The version of the deployer which will handle the service deployment.
     */
    version: string;
};

export type Deployment = {
    /**
     * The deployer tool which will handle the service deployment.
     */
    deployerTool: DeployerTool;
    /**
     * The credential type to do the deployment
     */
    credentialType?: CredentialType;
    /**
     * The list of availability zone configuration of the service.The list elements must be unique.
     */
    serviceAvailabilityConfig?: Array<AvailabilityZoneConfig>;
    /**
     * Deployment information for terraform based deployments. This is mandatory if the deployer kind is Terraform or OpenTofu
     */
    terraformDeployment?: TerraformDeployment;
    /**
     * Deployment information for Helm based deployments. This is mandatory if the deployer kind is Helm
     */
    helmDeployment?: HelmDeployment;
};

export type FlavorsWithPrice = {
    /**
     * The flavors of the managed service. The list elements must be unique.
     */
    serviceFlavors: Array<ServiceFlavorWithPrice>;
    /**
     * Impact on service when flavor is changed.
     */
    modificationImpact: ModificationImpact;
    /**
     * Whether the downgrading is allowed, default value: true.
     */
    isDowngradeAllowed: boolean;
    downgradeAllowed?: boolean;
};

export type HelmCoordinates = {
    /**
     * The repository of helm chart.
     */
    repository: string;
    /**
     * The version of the helm chart.
     */
    version: string;
};

export type HelmDeployment = {
    /**
     * The input variables for the helm deployment, which will be passed to the deployer.The list elements must be unique. All input variables are put together to build a JSON 'object' with each variable as a property of this object.
     */
    inputVariables: Array<InputVariable>;
    /**
     * The output variables for the helm deployment, which will be generated by the helm deployer. The list elements must be unique.
     */
    helmOutputVariables: Array<HelmOutputVariable>;
    /**
     * The kubernetes cluster for the helm deployment.
     */
    kubernetesCluster: KubernetesCluster;
    /**
     * The helm coordinates for the helm deployment.
     */
    helmCoordinates: HelmCoordinates;
};

export type HelmOutputVariable = {
    /**
     * The name of the output variable
     */
    name: string;
    /**
     * The type of the output variable
     */
    dataType: VariableDataType;
    /**
     * The description of the output variable
     */
    description?: string;
    /**
     * Sensitive scope of variable storage
     */
    sensitiveScope?: SensitiveScope;
    /**
     * The type of kubernetes resource
     */
    resourceType?: string;
};

export type InputVariable = {
    /**
     * The name of the deploy variable
     */
    name: string;
    /**
     * The kind of the deploy variable
     */
    kind: VariableKind;
    /**
     * The type of the deploy variable
     */
    dataType: VariableDataType;
    /**
     * The example value of the deploy variable
     */
    example?: string;
    /**
     * The description of the deploy variable
     */
    description: string;
    /**
     * The value of the deploy variable. Value can be provided for default variables
     */
    value?: string;
    /**
     * Indicates if the variable is mandatory
     */
    mandatory: boolean;
    /**
     * valueSchema of the variable. The key be any keyword that is part of the JSON schema definition which can be found here https://json-schema.org/draft/2020-12/meta/validation. Only the type field is taken from dataType parameter directly.
     */
    valueSchema?: {
        [key: string]: unknown;
    };
    /**
     * Sensitive scope of variable storage
     */
    sensitiveScope?: SensitiveScope;
    /**
     * Variable autofill. Defines if the variable must be one of the existing resources of a specific type.
     */
    autoFill?: AutoFill;
    /**
     * Variable modificationImpact
     */
    modificationImpact: ModificationImpact;
};

export type KubernetesCluster = {
    /**
     * The version of the kubernetes.
     */
    version: string;
    /**
     * The type of the kubernetes cluster.
     */
    type: KubernetesClusterType;
};

export enum KubernetesClusterType {
    DEDICATED = 'dedicated',
    SHARED = 'shared',
}

export type ModificationImpact = {
    /**
     * Is data lost when service configuration is modified.
     */
    isDataLost?: boolean;
    /**
     * Is service availability interrupted when the configuration is interrupted.
     */
    isServiceInterrupted?: boolean;
};

export enum ObjectActionType {
    CREATE = 'create',
    UPDATE = 'update',
    DELETE = 'delete',
}

export type ObjectIdentifier = {
    /**
     * the name of service object identifier.
     */
    name: string;
    /**
     * the value schema of service object identifier.
     */
    valueSchema: string;
};

export type ObjectManage = {
    /**
     * the type of service object action.
     */
    objectActionType: ObjectActionType;
    /**
     * the modificationImpact of service object manage.
     */
    modificationImpact: ModificationImpact;
    /**
     * the handler script of service object manage.
     */
    objectHandlerScript: ServiceChangeScript;
    /**
     * The service object parameters of service .The list elements must be unique. All parameters are put together to build a JSON 'object' with each parameter as a property of this object.
     */
    objectParameters?: Array<ObjectParameter>;
};

export type ObjectParameter = {
    /**
     * The name of the service object parameter
     */
    name: string;
    /**
     * The type of the service object  parameter
     */
    dataType: VariableDataType;
    /**
     * The description of the service object parameter
     */
    description: string;
    /**
     * The example value of the service object  parameter
     */
    example?: unknown;
    /**
     * valueSchema of the service config parameter. The key be any keyword that is part of the JSON schema definition which can be found here https://json-schema.org/draft/2020-12/schema
     */
    valueSchema?: {
        [key: string]: unknown;
    };
    /**
     * Sensitive scope of service config parameter storage
     */
    sensitiveScope?: SensitiveScope;
    /**
     * idicates whether the object parameter is mandatory.
     */
    isMandatory?: boolean;
    /**
     * the type of the linkedObject.
     */
    linkedObjectType?: string;
};

export type Ocl = {
    /**
     * The catalog of the service
     */
    category: Category;
    /**
     * The version of the Ocl
     */
    version: string;
    /**
     * The name of the managed service
     */
    name: string;
    /**
     * Short code of the service. This will be used in other configurations.
     */
    shortCode: string;
    /**
     * The version of the managed service
     */
    serviceVersion: string;
    /**
     * The description of the managed service
     */
    description: string;
    /**
     * The serviceVendor of the managed service
     */
    serviceVendor: string;
    /**
     * The icon of the managed service
     */
    icon: string;
    /**
     * The cloud service provider of the managed service
     */
    cloudServiceProvider: CloudServiceProvider;
    /**
     * The deployment of the managed service
     */
    deployment: Deployment;
    /**
     * The flavors of the managed service
     */
    flavors: FlavorsWithPrice;
    /**
     * The billing policy of the managed service
     */
    billing: Billing;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The contact details of the service provider.
     */
    serviceProviderContactDetails: ServiceProviderContactDetails;
    /**
     * End user license agreement content of the service.
     */
    eula?: string;
    /**
     * manage service configuration.
     */
    serviceConfigurationManage?: ServiceChangeManage;
    /**
     * manage service action.
     */
    serviceActions?: Array<ServiceAction>;
    /**
     * manage service object.
     */
    serviceObjects?: Array<ServiceObject>;
};

export type OutputVariable = {
    /**
     * The name of the output variable
     */
    name: string;
    /**
     * The type of the output variable
     */
    dataType: VariableDataType;
    /**
     * The description of the output variable
     */
    description?: string;
    /**
     * Sensitive scope of variable storage
     */
    sensitiveScope?: SensitiveScope;
};

export type Price = {
    /**
     * The value of the cost.
     */
    cost: number;
    /**
     * The currency of the cost.
     */
    currency: Currency;
    /**
     * The period of the cost.
     */
    period?: PricingPeriod;
};

export type PriceWithRegion = {
    /**
     * The defined region name. If the special name 'any' provided, this price for all unknown regions.
     */
    regionName: string;
    /**
     * The defined site name. If the special name 'default' provided, this price for all sites.
     */
    siteName: string;
    /**
     * The price for the defined region and the defined site.
     */
    price: Price;
};

export enum PricingPeriod {
    YEARLY = 'yearly',
    MONTHLY = 'monthly',
    DAILY = 'daily',
    HOURLY = 'hourly',
    ONE_TIME = 'oneTime',
}

export type RatingMode = {
    /**
     * The fixed prices of the flavor in the managed service for regions. The fixed price of the region includes all prices and shown to the customer.
     */
    fixedPrices?: Array<PriceWithRegion>;
    /**
     * The resource usage of the flavor in the managed service.
     */
    resourceUsage?: ResourceUsage;
    /**
     * Whether the price is only for management layer. Consumption of the workload resources will be billed additionally..
     */
    isPriceOnlyForManagementLayer: boolean;
};

export type Region = {
    /**
     * The name of the region
     */
    name: string;
    /**
     * The site with the region belongs to, such as default, Chinese Mainland, International,
     */
    site: string;
    /**
     * The area which the region belongs to, such as Asia, Europe, Africa
     */
    area: string;
};

export type Resource = {
    /**
     * The count of the same resource.
     */
    count: number;
    /**
     * The kind of the same resource.
     */
    deployResourceKind: DeployResourceKind;
    /**
     * The properties of the same resource.
     */
    properties?: {
        [key: string]: string;
    };
};

export type ResourceUsage = {
    /**
     * The resources of the flavor of the manged service.
     */
    resources: Array<Resource>;
    /**
     * The license prices of the flavor of the manged service.
     */
    licensePrices?: Array<PriceWithRegion>;
    /**
     * The listed price list of the flavor of the manged service.
     */
    markUpPrices?: Array<PriceWithRegion>;
};

export type ScriptsRepo = {
    /**
     * URL of the repo
     */
    repoUrl: string;
    /**
     * Branch to be checked out. Can be branch or a Tag
     */
    branch: string;
    /**
     * Directory in the repo where scripts are present. If not provided, the root directory of the repo is considered
     */
    scriptsPath?: string;
};

export enum SensitiveScope {
    NONE = 'none',
    ONCE = 'once',
    ALWAYS = 'always',
}

export type ServiceAction = {
    /**
     * the name of service action.
     */
    name: string;
    /**
     * the tool used to manage the service action.
     */
    type: ConfigurationManagerTool;
    /**
     * The collection of the action manage script.
     */
    actionManageScripts?: Array<ServiceChangeScript>;
    /**
     * The configuration parameters of service .The list elements must be unique. All parameters are put together to build a JSON 'object' with each parameter as a property of this object.
     */
    actionParameters?: Array<ServiceChangeParameter>;
};

export type ServiceChangeManage = {
    /**
     * the tool used to manage the service configuration.
     */
    type: ConfigurationManagerTool;
    /**
     * the version of the agent that will be used by service resources.
     */
    agentVersion: string;
    /**
     * The collection of the configuration manage script.
     */
    configManageScripts?: Array<ServiceChangeScript>;
    /**
     * The collection of service configuration parameters.
     */
    configurationParameters?: Array<ServiceChangeParameter>;
};

export type ServiceChangeParameter = {
    /**
     * The name of the service config parameter
     */
    name: string;
    /**
     * The kind of the service config parameter
     */
    kind: VariableKind;
    /**
     * The type of the service config parameter
     */
    dataType: VariableDataType;
    /**
     * The example value of the service config parameter
     */
    example?: string;
    /**
     * The description of the service config parameter
     */
    description: string;
    /**
     * The value of the service config parameter. Value can be provided for initial value
     */
    value?: string;
    /**
     * The init value of the service config parameter
     */
    initialValue: unknown;
    /**
     * valueSchema of the variable. The key can be any keyword that is part of the JSON schema definition which can be found here https://json-schema.org/draft/2020-12/meta/validation. Only the type field is taken from dataType parameter directly.
     */
    valueSchema?: {
        [key: string]: unknown;
    };
    /**
     * Sensitive scope of service config parameter storage
     */
    sensitiveScope?: SensitiveScope;
    /**
     * Service config parameter modificationImpact
     */
    modificationImpact: ModificationImpact;
    /**
     * Whether the service configuration parameters are read-only
     */
    isReadOnly: boolean;
    /**
     * Service component which manages this configuration parameter.
     */
    managedBy: string;
};

export type ServiceChangeScript = {
    /**
     * should be the name of the resource available in the deployer script.
     */
    changeHandler: string;
    /**
     * Means should the configuration update run on each node of the specific component or just one.
     */
    runOnlyOnce: boolean;
    /**
     * Ansible script configuration details.
     */
    ansibleScriptConfig: AnsibleScriptConfig;
};

export type ServiceFlavorWithPrice = {
    /**
     * The flavor name
     */
    name: string;
    /**
     * The properties of the flavor
     */
    properties: {
        [key: string]: string;
    };
    /**
     * The priority of the flavor. The larger value means lower priority.
     */
    priority: number;
    /**
     * Important features and differentiators of the flavor.
     */
    features?: Array<string>;
    /**
     * The pricing of the flavor
     */
    pricing: RatingMode;
};

/**
 * Defines which cloud service account is used for deploying cloud resources.
 */
export enum ServiceHostingType {
    SELF = 'self',
    SERVICE_VENDOR = 'service-vendor',
}

export type ServiceObject = {
    /**
     * the type of service object.
     */
    type: string;
    /**
     * the identifier of service object.
     */
    objectIdentifier: ObjectIdentifier;
    /**
     * the tool used to manage the service object.
     */
    handlerType: ConfigurationManagerTool;
    /**
     * The collection of the service object manage.
     */
    objectsManage?: Array<ObjectManage>;
};

export type ServiceProviderContactDetails = {
    /**
     * List of the email details of the service provider. The list elements must be unique.
     */
    emails?: Array<string>;
    /**
     * List of the phone details of the service provider. The list elements must be unique.
     */
    phones?: Array<string>;
    /**
     * List of the chat details of the service provider. The list elements must be unique.
     */
    chats?: Array<string>;
    /**
     * List of the website details of the service provider. The list elements must be unique.
     */
    websites?: Array<string>;
};

export type TerraformDeployment = {
    /**
     * Deployment scripts stored in a Map. file name as the key and content as the value. Either scriptFiles or scriptsRepo must be provided.
     */
    scriptFiles?: {
        [key: string]: string;
    };
    /**
     * Deployment scripts hosted on a GIT repo. Either scriptFiles or scriptsRepo must be provided.
     */
    scriptsRepo?: ScriptsRepo;
    /**
     * The input variables for the deployment, which will be passed to the deployer.The list elements must be unique. All input variables are put together to build a JSON 'object' with each variable as a property of this object.
     */
    inputVariables: Array<InputVariable>;
    /**
     * The output variables for the deployment, which will be generated by the deployer. The list elements must be unique.
     */
    outputVariables: Array<OutputVariable>;
};

export enum VariableDataType {
    STRING = 'string',
    NUMBER = 'number',
    BOOLEAN = 'boolean',
    ARRAY = 'array',
}

/**
 * - `fix_env`: Values for variable of this type are defined by the managed service provider
 * in the OCL template. Runtime will inject it to deployer as environment variables.
 * This variable is not visible to the end user.
 * - `fix_variable`: Values for variable of this type are defined by the managed service
 * provider in the OCL template. Runtime will inject it to deployer as usual variables.
 * This variable is not visible to the end user.
 * - `env`: Value for a variable of this type can be provided by end user.
 * If marked as mandatory then end user must provide value to this variable.
 * If marked as optional and if end user does not provide it,
 * then the fallback value to this variable is read by runtime (it can read from other sources,
 * e.g., OS env variables). This variable is injected as an environment
 * variable to the deployer.
 * - `variable`: Value for a variable of this type can be provided by end user.
 * If marked as mandatory then end user must provide value to this variable.
 * If marked as optional and if end user does not provide it,
 * then the fallback value to this variable is read by runtime (it can read from other sources,
 * e.g., OS env variables). This variable is injected as a regular variable to the deployer.
 * - `env_env`: Value to this variable is read by runtime
 * (it can read from other sources, e.g., OS env variables)
 * and injected as an environment variable to the deployer.
 * End user cannot see or change this variable.
 * - `env_variable`: Value to this variable is read by runtime
 * (it can read from other sources, e.g., OS env variables)
 * and injected as a regular variable to the deployer.
 * End user cannot see or change this variable.
 */
export enum VariableKind {
    FIX_ENV = 'fix_env',
    FIX_VARIABLE = 'fix_variable',
    ENV = 'env',
    VARIABLE = 'variable',
    ENV_ENV = 'env_env',
    ENV_VARIABLE = 'env_variable',
}

export type ServiceTemplateRequestInfo = {
    /**
     * ID of the service template.
     */
    serviceTemplateId: string;
    /**
     * ID of the request history of the service template.
     */
    requestId: string;
    requestSubmittedForReview?: boolean;
};

export type ServicePolicyUpdateRequest = {
    /**
     * The flavor names to which the policy belongs. If the list is empty, then the policy will be executed for during service deployment of all flavors.
     */
    flavorNames?: Array<string>;
    /**
     * The policy.
     */
    policy?: string;
    /**
     * Is the policy enabled. true:enabled;false:disabled.
     */
    enabled?: boolean;
};

export type ServicePolicy = {
    /**
     * The id of the policy.
     */
    servicePolicyId: string;
    /**
     * The valid policy belongs to the service.
     */
    policy: string;
    /**
     * The id of registered service template which the policy belongs to.
     */
    serviceTemplateId: string;
    /**
     * The flavor name list which the policy belongs to. If the list is empty, then the policy will be executed for during service deployment of all flavors.
     */
    flavorNameList?: Array<string>;
    /**
     * Is the policy enabled.
     */
    enabled: boolean;
    /**
     * Time of the policy created.
     */
    createdTime: string;
    /**
     * Time of the policy updated.
     */
    lastModifiedTime: string;
};

export type UserPolicyUpdateRequest = {
    /**
     * The csp which the policy belongs to.
     */
    csp?: Csp;
    /**
     * The policy.
     */
    policy?: string;
    /**
     * Is the policy enabled. true:enabled;false:disabled.
     */
    enabled?: boolean;
};

export type UserPolicy = {
    /**
     * The id of the policy.
     */
    userPolicyId: string;
    /**
     * The valid policy created by the user.
     */
    policy: string;
    /**
     * The csp which the policy belongs to.
     */
    csp: Csp;
    /**
     * Is the policy enabled.
     */
    enabled: boolean;
    /**
     * Time of the policy created.
     */
    createdTime: string;
    /**
     * Time of the policy updated.
     */
    lastModifiedTime: string;
};

export type ReviewServiceTemplateRequest = {
    /**
     * The result of review registration.
     */
    reviewResult: ServiceReviewResult;
    /**
     * The comment of review registration.
     */
    reviewComment: string;
};

export enum ServiceReviewResult {
    APPROVED = 'approved',
    REJECTED = 'rejected',
}

export type AnsibleTaskResult = {
    /**
     * name of the Ansible task
     */
    name: string;
    /**
     * Depicts if the task is successful
     */
    isSuccessful: boolean;
    /**
     * Data from the task. Will be returned both for successful and failure cases.
     */
    message?: string;
};

/**
 * result of the service change request.
 */
export type ServiceChangeResult = {
    /**
     * describes if the change is successfully executed.
     */
    isSuccessful: boolean;
    /**
     * error description if the task failed.
     */
    error?: string;
    /**
     * describes result of each Ansible task executed by the agent.
     */
    tasks?: Array<AnsibleTaskResult>;
};

export type DeployRequest = {
    /**
     * The category of the service
     */
    category: Category;
    /**
     * The name of the service ordered.
     */
    serviceName: string;
    /**
     * Customer's name for the service. Used only for customer's reference.If not provided, this value will be auto-generated
     */
    customerServiceName?: string;
    /**
     * The version of service
     */
    version: string;
    /**
     * The region of the provider.
     */
    region: Region;
    /**
     * The csp of the Service.
     */
    csp: Csp;
    /**
     * The flavor of the Service.
     */
    flavor: string;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The properties for the requested service
     */
    serviceRequestProperties?: {
        [key: string]: unknown;
    };
    /**
     * The availability zones to deploy the service instance.
     */
    availabilityZones?: {
        [key: string]: string;
    };
    /**
     * The billing mode of the managed service.
     */
    billingMode: BillingMode;
    eulaAccepted?: boolean;
};

export type ServicePortingRequest = {
    /**
     * The category of the service
     */
    category: Category;
    /**
     * The name of the service ordered.
     */
    serviceName: string;
    /**
     * Customer's name for the service. Used only for customer's reference.If not provided, this value will be auto-generated
     */
    customerServiceName?: string;
    /**
     * The version of service
     */
    version: string;
    /**
     * The region of the provider.
     */
    region: Region;
    /**
     * The csp of the Service.
     */
    csp: Csp;
    /**
     * The flavor of the Service.
     */
    flavor: string;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The properties for the requested service
     */
    serviceRequestProperties?: {
        [key: string]: unknown;
    };
    /**
     * The availability zones to deploy the service instance.
     */
    availabilityZones?: {
        [key: string]: string;
    };
    /**
     * The billing mode of the managed service.
     */
    billingMode: BillingMode;
    /**
     * The id of the service to port
     */
    originalServiceId: string;
    eulaAccepted?: boolean;
};

export type ServicePolicyCreateRequest = {
    /**
     * The id of registered service template which the policy belongs to.
     */
    serviceTemplateId: string;
    /**
     * The flavor name list which the policy belongs to. If the list is empty, then the policy will be executed for during service deployment of all flavors.
     */
    flavorNameList?: Array<string>;
    /**
     * The policy.
     */
    policy: string;
    /**
     * Is the policy enabled. true:enabled;false:disabled.
     */
    enabled: boolean;
};

export type UserPolicyCreateRequest = {
    /**
     * The csp which the policy belongs to.
     */
    csp: Csp;
    /**
     * The policy.
     */
    policy: string;
    /**
     * Is the policy enabled. true:enabled;false:disabled.
     */
    enabled: boolean;
};

export enum WorkFlowTaskStatus {
    DONE = 'done',
    FAILED = 'failed',
}

export type WorkFlowTask = {
    /**
     * The id of the ProcessInstance
     */
    processInstanceId: string;
    /**
     * The name of the ProcessInstance
     */
    processInstanceName?: string;
    /**
     * The id of the ProcessDefinition
     */
    processDefinitionId: string;
    /**
     * The name of the ProcessDefinition
     */
    processDefinitionName: string;
    /**
     * The execution id of the ProcessInstance
     */
    executionId: string;
    /**
     * The id of the task
     */
    taskId: string;
    /**
     * The name of the task
     */
    taskName: string;
    /**
     * The businessKey of the Process
     */
    businessKey?: string;
    /**
     * The status of the Task
     */
    taskStatus: WorkFlowTaskStatus;
    /**
     * The create time of the task
     */
    createdTime: string;
};

export type AbstractCredentialInfo = CredentialVariables & {
    /**
     * The cloud service provider of the credential.
     */
    csp: Csp;
    /**
     * The site which the credentials belong to.
     */
    site: string;
    /**
     * The type of the credential, this field is provided by the plugin of cloud service provider.
     */
    type: CredentialType;
    /**
     * The name of the credential, this field is provided by the plugin of cloud service provider. The value of this field must be unique between credentials with the same csp and type.
     */
    name: string;
    /**
     * The description of the credential,this field is provided by the plugin of cloud service provider.
     */
    description: string;
    /**
     * The id of user who created the credential.
     */
    userId?: string;
};

export type CredentialVariables = {
    /**
     * The cloud service provider of the credential.
     */
    csp: Csp;
    /**
     * The site which the credentials belong to.
     */
    site: string;
    /**
     * The type of the credential, this field is provided by the plugin of cloud service provider.
     */
    type: CredentialType;
    /**
     * The name of the credential, this field is provided by the plugin of cloud service provider. The value of this field must be unique between credentials with the same csp and type.
     */
    name: string;
    /**
     * The description of the credential,this field is provided by the plugin of cloud service provider.
     */
    description: string;
    /**
     * The id of user who created the credential.
     */
    userId?: string;
    /**
     * The variables list of the credential.
     */
    variables: Array<CredentialVariable>;
};

export type BackendSystemStatus = {
    /**
     * The type of backend system.
     */
    backendSystemType: BackendSystemType;
    /**
     * The name of backend system.
     */
    name: string;
    /**
     * The health status of backend system.
     */
    healthStatus: HealthStatus;
    /**
     * The endpoint of backend system. This filed is shown when the user have role 'admin' otherwise it is null.
     */
    endpoint?: string;
    /**
     * The details why health is not ok.This filed is shown when the user have role 'admin' otherwise it is null.
     */
    details?: string;
};

export enum BackendSystemType {
    IDENTITY_PROVIDER = 'Identity Provider',
    DATABASE = 'Database',
    TERRA_BOOT = 'Terra Boot',
    TOFU_MAKER = 'Tofu Maker',
    POLICY_MAN = 'Policy Man',
    CACHE_PROVIDER = 'Cache Provider',
    OPEN_TELEMETRY_COLLECTOR = 'OpenTelemetry Collector',
}

export enum HealthStatus {
    OK = 'OK',
    NOK = 'NOK',
}

export type StackStatus = {
    /**
     * The health status of Xpanse service.
     */
    healthStatus: HealthStatus;
    /**
     * The health status of the entire xpanse stack. This contains all components that are connected to xpanse.
     */
    backendSystemStatuses: Array<BackendSystemStatus>;
};

export enum ServiceDeploymentState {
    DEPLOYING = 'deploying',
    DEPLOYMENT_SUCCESSFUL = 'deployment successful',
    DEPLOYMENT_FAILED = 'deployment failed',
    DESTROYING = 'destroying',
    DESTROY_SUCCESSFUL = 'destroy successful',
    DESTROY_FAILED = 'destroy failed',
    MANUAL_CLEANUP_REQUIRED = 'manual cleanup required',
    ROLLBACK_FAILED = 'rollback failed',
    MODIFYING = 'modifying',
    MODIFICATION_FAILED = 'modification failed',
    MODIFICATION_SUCCESSFUL = 'modification successful',
    ROLLING_BACK = 'rolling back',
}

export type DeployedService = {
    /**
     * The ID of the service
     */
    serviceId: string;
    /**
     * The catalog of the service
     */
    category: Category;
    /**
     * The name of the service
     */
    name: string;
    /**
     * Customer's name for the service. Used only for customer's reference.If not provided, this value will be auto-generated
     */
    customerServiceName?: string;
    /**
     * The version of the service
     */
    version: string;
    /**
     * The provider of the service
     */
    csp: Csp;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The region of the service.
     */
    region: Region;
    /**
     * The availability zones of the service
     */
    availabilityZones?: {
        [key: string]: string;
    };
    /**
     * The flavor of the service
     */
    flavor: string;
    /**
     * The billing mode of the managed service.
     */
    billingMode: BillingMode;
    /**
     * The input properties to deploy the service.
     */
    inputProperties?: {
        [key: string]: string;
    };
    /**
     * The properties of the deployed service.
     */
    deployedServiceProperties?: {
        [key: string]: string;
    };
    /**
     * The id of the Service Template
     */
    serviceTemplateId: string;
    /**
     * The id of the user who deployed the service.
     */
    userId?: string;
    /**
     * The deployment state of the service
     */
    serviceDeploymentState: ServiceDeploymentState;
    /**
     * The run state of the service
     */
    serviceState: ServiceState;
    /**
     * Time of register service.
     */
    createdTime: string;
    /**
     * Time of update service.
     */
    lastModifiedTime: string;
    /**
     * Time of start service.
     */
    lastStartedAt?: string;
    /**
     * Time of stop service.
     */
    lastStoppedAt?: string;
    /**
     * The locks whether the service can be modified or destroyed.
     */
    lockConfig?: ServiceLockConfig;
    /**
     * Details of the service configuration.
     */
    serviceConfigurationDetails?: ServiceConfigurationDetails;
};

export type ServiceConfigurationDetails = {
    /**
     * Defines the current configuration of the service.
     */
    configuration?: {
        [key: string]: unknown;
    };
    /**
     * Timestamp when the configuration was first created.
     */
    createdTime?: string;
    /**
     * Timestamp when the configuration was last updated.
     */
    updatedTime?: string;
};

export enum ServiceState {
    NOT_RUNNING = 'not running',
    RUNNING = 'running',
    STARTING = 'starting',
    STOPPING = 'stopping',
    STOPPED = 'stopped',
    RESTARTING = 'restarting',
    UNKNOWN = 'unknown',
}

export type EndUserFlavors = {
    /**
     * The flavor name
     */
    name: string;
    /**
     * The properties of the flavor
     */
    properties: {
        [key: string]: string;
    };
    /**
     * The priority of the flavor. The larger value means lower priority.
     */
    priority: number;
    /**
     * Important features and differentiators of the flavor.
     */
    features?: Array<string>;
    /**
     * The flavors of the orderable service.
     */
    serviceFlavors: Array<ServiceFlavor>;
    /**
     * Impact on service when flavor is changed.
     */
    modificationImpact: ModificationImpact;
    /**
     * Whether the downgrading is allowed, default value: true.
     */
    isDowngradeAllowed: boolean;
    downgradeAllowed?: boolean;
};

export type Link = {
    rel?: string;
    href?: string;
    hreflang?: string;
    media?: string;
    title?: string;
    type?: string;
    deprecation?: string;
    profile?: string;
    name?: string;
};

export type ServiceFlavor = {
    /**
     * The flavor name
     */
    name: string;
    /**
     * The properties of the flavor
     */
    properties: {
        [key: string]: string;
    };
    /**
     * The priority of the flavor. The larger value means lower priority.
     */
    priority: number;
    /**
     * Important features and differentiators of the flavor.
     */
    features?: Array<string>;
};

export type UserOrderableServiceVo = {
    /**
     * The id of the orderable service.
     */
    serviceTemplateId: string;
    /**
     * The category of the orderable service.
     */
    category: Category;
    /**
     * The name of the orderable service.
     */
    name: string;
    /**
     * Short code of the service.
     */
    shortCode: string;
    /**
     * The version of the orderable service.
     */
    version: string;
    /**
     * The Cloud Service Provider of the orderable service.
     */
    csp: Csp;
    /**
     * The regions of the Cloud Service Provider.
     */
    regions: Array<Region>;
    /**
     * The serviceVendor of the orderable service.
     */
    serviceVendor: string;
    /**
     * The description of the orderable service.
     */
    description: string;
    /**
     * The icon of the orderable service.
     */
    icon: string;
    /**
     * The input variables for the deployment, which will be passed to the deployer.
     */
    inputVariables: Array<InputVariable>;
    /**
     * The output variables for the deployment, which will be generated by the deployer.
     */
    outputVariables: Array<OutputVariable>;
    /**
     * The flavors of the orderable service.
     */
    flavors: EndUserFlavors;
    /**
     * The billing policy of the orderable service.
     */
    billing: Billing;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The contact details of the service provider.
     */
    serviceProviderContactDetails: ServiceProviderContactDetails;
    /**
     * The list of availability zone configuration of the service.
     */
    serviceAvailabilityConfig?: Array<AvailabilityZoneConfig>;
    /**
     * End user license agreement content of the service.
     */
    eula?: string;
    /**
     * The collection of service configuration parameters.
     */
    configurationParameters?: Array<ServiceChangeParameter>;
    /**
     * manage service action.
     */
    serviceActions?: Array<ServiceAction>;
    /**
     * manage service object.
     */
    serviceObjects?: Array<ServiceObject>;
    links?: Array<Link>;
};

export type DeployResource = {
    /**
     * The type of the resource as defined by the deployer used to deploy the service. Example, in case of terraform this will be the type of the resource defined by the terraform provider.
     */
    groupType: string;
    /**
     * The group to which the resource belongs to. A service can have multiple types of resources. This defines the type of resource. The name of resource group is controlled in the service template.
     */
    groupName: string;
    /**
     * The id of the deployed resource.
     */
    resourceId: string;
    /**
     * The name of the deployed resource.
     */
    resourceName: string;
    /**
     * The kind of the deployed resource.
     */
    resourceKind: DeployResourceKind;
    /**
     * The properties of the deployed resource.
     */
    properties: {
        [key: string]: string;
    };
};

export enum ServiceOrderType {
    DEPLOY = 'deploy',
    RETRY = 'retry',
    ROLLBACK = 'rollback',
    MODIFY = 'modify',
    DESTROY = 'destroy',
    PORT = 'port',
    RECREATE = 'recreate',
    LOCK_CHANGE = 'lockChange',
    CONFIG_CHANGE = 'configChange',
    SERVICE_ACTION = 'serviceAction',
    PURGE = 'purge',
    SERVICE_START = 'serviceStart',
    SERVICE_STOP = 'serviceStop',
    SERVICE_RESTART = 'serviceRestart',
    OBJECT_CREATE = 'objectCreate',
    OBJECT_MODIFY = 'objectModify',
    OBJECT_DELETE = 'objectDelete',
}

export enum OrderStatus {
    CREATED = 'created',
    IN_PROGRESS = 'in-progress',
    SUCCESSFUL = 'successful',
    FAILED = 'failed',
}

export type ServiceOrderDetails = {
    /**
     * The id of the service order.
     */
    orderId: string;
    /**
     * The id of the deployed service.
     */
    serviceId: string;
    /**
     * The task type of the service order.
     */
    taskType: ServiceOrderType;
    /**
     * The task status of the service order.
     */
    orderStatus: OrderStatus;
    /**
     * The id of the original service.
     */
    originalServiceId?: string;
    /**
     * The id of the parent service order.
     */
    parentOrderId?: string;
    /**
     * The id of the workflow.
     */
    workflowId?: string;
    /**
     * The error response if the service order task failed.
     */
    errorResponse?: ErrorResponse;
    /**
     * The id of the user who created the service order.
     */
    userId?: string;
    /**
     * The started time of the service order.
     */
    startedTime: string;
    /**
     * The completed time of the service order.
     */
    completedTime?: string;
    /**
     * The requests of the service order.
     */
    requestBody?: {
        [key: string]: unknown;
    };
    /**
     * The result properties of the service order.
     */
    resultProperties?: {
        [key: string]: unknown;
    };
};

export type DeploymentStatusUpdate = {
    /**
     * Current state of the deployment request.
     */
    serviceDeploymentState: ServiceDeploymentState;
    /**
     * Describes if the deployment request is now completed
     */
    isOrderCompleted: boolean;
};

export type ServiceOrderStatusUpdate = {
    /**
     * Current task status of the service order.
     */
    orderStatus: OrderStatus;
    /**
     * Describes if the service order is now completed.
     */
    isOrderCompleted: boolean;
    /**
     * The error message if the service order failed.
     */
    error?: ErrorResponse;
};

export type ServiceObjectDetails = {
    /**
     * The id of the service object.
     */
    objectId: string;
    /**
     * The id of the service deployment.
     */
    serviceId: string;
    /**
     * The type of service object.
     */
    objectType: string;
    /**
     * The name of service object identifier.
     */
    objectIdentifierName: string;
    /**
     * The collection of dependent object IDs.
     */
    dependentObjectIds?: Array<string>;
    /**
     * The collection of service object parameter.
     */
    parameters: {
        [key: string]: unknown;
    };
    /**
     * The collection of ids of the service orders result in the object.
     */
    objectOrderHistory: Array<ServiceOrderDetails>;
};

export type DeployedServiceDetails = {
    /**
     * The ID of the service
     */
    serviceId: string;
    /**
     * The catalog of the service
     */
    category: Category;
    /**
     * The name of the service
     */
    name: string;
    /**
     * Customer's name for the service. Used only for customer's reference.If not provided, this value will be auto-generated
     */
    customerServiceName?: string;
    /**
     * The version of the service
     */
    version: string;
    /**
     * The provider of the service
     */
    csp: Csp;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The region of the service.
     */
    region: Region;
    /**
     * The availability zones of the service
     */
    availabilityZones?: {
        [key: string]: string;
    };
    /**
     * The flavor of the service
     */
    flavor: string;
    /**
     * The billing mode of the managed service.
     */
    billingMode: BillingMode;
    /**
     * The input properties to deploy the service.
     */
    inputProperties?: {
        [key: string]: string;
    };
    /**
     * The properties of the deployed service.
     */
    deployedServiceProperties?: {
        [key: string]: string;
    };
    /**
     * The id of the Service Template
     */
    serviceTemplateId: string;
    /**
     * The id of the user who deployed the service.
     */
    userId?: string;
    /**
     * The deployment state of the service
     */
    serviceDeploymentState: ServiceDeploymentState;
    /**
     * The run state of the service
     */
    serviceState: ServiceState;
    /**
     * Time of register service.
     */
    createdTime: string;
    /**
     * Time of update service.
     */
    lastModifiedTime: string;
    /**
     * Time of start service.
     */
    lastStartedAt?: string;
    /**
     * Time of stop service.
     */
    lastStoppedAt?: string;
    /**
     * The locks whether the service can be modified or destroyed.
     */
    lockConfig?: ServiceLockConfig;
    /**
     * Details of the service configuration.
     */
    serviceConfigurationDetails?: ServiceConfigurationDetails;
    /**
     * The resource list of the deployed service.
     */
    deployResources?: Array<DeployResource>;
};

export type VendorHostedDeployedServiceDetails = {
    /**
     * The ID of the service
     */
    serviceId: string;
    /**
     * The catalog of the service
     */
    category: Category;
    /**
     * The name of the service
     */
    name: string;
    /**
     * Customer's name for the service. Used only for customer's reference.If not provided, this value will be auto-generated
     */
    customerServiceName?: string;
    /**
     * The version of the service
     */
    version: string;
    /**
     * The provider of the service
     */
    csp: Csp;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * The region of the service.
     */
    region: Region;
    /**
     * The availability zones of the service
     */
    availabilityZones?: {
        [key: string]: string;
    };
    /**
     * The flavor of the service
     */
    flavor: string;
    /**
     * The billing mode of the managed service.
     */
    billingMode: BillingMode;
    /**
     * The input properties to deploy the service.
     */
    inputProperties?: {
        [key: string]: string;
    };
    /**
     * The properties of the deployed service.
     */
    deployedServiceProperties?: {
        [key: string]: string;
    };
    /**
     * The id of the Service Template
     */
    serviceTemplateId: string;
    /**
     * The id of the user who deployed the service.
     */
    userId?: string;
    /**
     * The deployment state of the service
     */
    serviceDeploymentState: ServiceDeploymentState;
    /**
     * The run state of the service
     */
    serviceState: ServiceState;
    /**
     * Time of register service.
     */
    createdTime: string;
    /**
     * Time of update service.
     */
    lastModifiedTime: string;
    /**
     * Time of start service.
     */
    lastStartedAt?: string;
    /**
     * Time of stop service.
     */
    lastStoppedAt?: string;
    /**
     * The locks whether the service can be modified or destroyed.
     */
    lockConfig?: ServiceLockConfig;
    /**
     * Details of the service configuration.
     */
    serviceConfigurationDetails?: ServiceConfigurationDetails;
};

export enum ServiceChangeStatus {
    PENDING = 'pending',
    PROCESSING = 'processing',
    SUCCESSFUL = 'successful',
    ERROR = 'error',
}

export type ServiceChangeOrderDetails = {
    /**
     * The id of the order.
     */
    orderId: string;
    /**
     * Order status of service update request.
     */
    orderStatus: OrderStatus;
    /**
     * service change request properties.
     */
    serviceChangeRequestProperties: {
        [key: string]: unknown;
    };
    /**
     * Collection of service change details requests generated for the specific change order.
     */
    serviceChangeRequests: Array<ServiceChangeRequestDetails>;
};

export type ServiceChangeRequestDetails = {
    /**
     * ID of the change request created as part of the change order.
     */
    changeId: string;
    /**
     * name of the resource on which the change request is executed. Null means any one of the resources that is part of the service and is of type configManager can execute it and until now none of the resource have picked up this request.
     */
    resourceName?: string;
    /**
     * type of the resource in the service that must manage the change request.
     */
    changeHandler: string;
    /**
     * result of service change request
     */
    resultMessage?: string;
    /**
     * parameters sent to the agent.
     */
    properties: {
        [key: string]: unknown;
    };
    /**
     * status of service change request.
     */
    status: ServiceChangeStatus;
};

export enum ServiceTemplateRegistrationState {
    IN_REVIEW = 'in-review',
    APPROVED = 'approved',
    CANCELLED = 'cancelled',
    REJECTED = 'rejected',
}

export type ServiceTemplateDetailVo = {
    /**
     * ID of the registered service.
     */
    serviceTemplateId: string;
    /**
     * Name of the registered service.
     */
    name: string;
    /**
     * Short code of the service. This will be used in other configurations.
     */
    shortCode: string;
    /**
     * Version of the registered service.
     */
    version: string;
    /**
     * Csp of the registered service.
     */
    csp: Csp;
    /**
     * Category of the registered service.
     */
    category: Category;
    /**
     * ServiceVendor of the user who registered service template.
     */
    serviceVendor: string;
    /**
     * The regions of the Cloud Service Provider.
     */
    regions: Array<Region>;
    /**
     * The description of the registered service.
     */
    description: string;
    /**
     * The icon of the registered service.
     */
    icon: string;
    /**
     * The deployment of the managed service
     */
    deployment: Deployment;
    /**
     * The flavors of the registered service.
     */
    flavors: FlavorsWithPrice;
    /**
     * The billing policy of the registered service.
     */
    billing: Billing;
    /**
     * Defines which cloud service account is used for deploying cloud resources.
     */
    serviceHostingType: ServiceHostingType;
    /**
     * createdTime of the registered service.
     */
    createdTime: string;
    /**
     * Last updateTime of the registered service.
     */
    lastModifiedTime: string;
    /**
     * Registration state of service template.
     */
    serviceTemplateRegistrationState: ServiceTemplateRegistrationState;
    /**
     * If any request for the service template has a review in-progress.
     */
    isReviewInProgress: boolean;
    /**
     * Is available in catalog.
     */
    isAvailableInCatalog: boolean;
    /**
     * The contact details of the service provider.
     */
    serviceProviderContactDetails: ServiceProviderContactDetails;
    /**
     * End user license agreement content of the service.
     */
    eula?: string;
    /**
     * manage service configuration.
     */
    serviceConfigurationManage?: ServiceChangeManage;
    /**
     * manage service action.
     */
    serviceActions?: Array<ServiceAction>;
    /**
     * manage service object.
     */
    serviceObjects?: Array<ServiceObject>;
    links?: Array<Link>;
};

export enum ServiceTemplateRequestType {
    REGISTER = 'register',
    UPDATE = 'update',
    UNPUBLISH = 'unpublish',
    REPUBLISH = 'republish',
}

export enum ServiceTemplateRequestStatus {
    IN_REVIEW = 'in-review',
    ACCEPTED = 'accepted',
    REJECTED = 'rejected',
    CANCELLED = 'cancelled',
}

export type ServiceTemplateRequestHistory = {
    /**
     * ID of the service template.
     */
    serviceTemplateId: string;
    /**
     * ID of the request history of the service template.
     */
    requestId: string;
    /**
     * Type of the request.
     */
    requestType: ServiceTemplateRequestType;
    /**
     * Status of the request.
     */
    requestStatus: ServiceTemplateRequestStatus;
    /**
     * Comment of the review request.
     */
    reviewComment?: string;
    /**
     * Status of the request.
     */
    blockTemplateUntilReviewed?: boolean;
    /**
     * Create time of the service template request.
     */
    createdTime: string;
    /**
     * Last update time of the service template request.
     */
    lastModifiedTime: string;
    requestSubmittedForReview?: boolean;
};

export type FlavorPriceResult = {
    /**
     * The name of the flavor.
     */
    flavorName: string;
    /**
     * The billing mode of the price.
     */
    billingMode: BillingMode;
    /**
     * The recurring price of the flavor.
     */
    recurringPrice?: Price;
    /**
     * The one time payment price of the flavor.
     */
    oneTimePaymentPrice?: Price;
    /**
     * Error reason when price calculation fails.
     */
    errorMessage?: string;
    successful?: boolean;
};

export enum MonitorResourceType {
    CPU = 'cpu',
    MEM = 'mem',
    VM_NETWORK_INCOMING = 'vm_network_incoming',
    VM_NETWORK_OUTGOING = 'vm_network_outgoing',
}

export type Metric = {
    /**
     * The name of the metric.
     */
    name: string;
    /**
     * The description of the metric.
     */
    description?: string;
    /**
     * The type of the metric.
     */
    type: MetricType;
    /**
     * The resource type of the metric.
     */
    monitorResourceType: MonitorResourceType;
    /**
     * The unit of the metric.
     */
    unit: MetricUnit;
    /**
     * The labels of the metric.
     */
    labels?: {
        [key: string]: string;
    };
    /**
     * The list of the metric items.
     */
    metrics?: Array<MetricItem>;
};

export type MetricItem = {
    /**
     * The labels for the MetricItem.
     */
    labels?: {
        [key: string]: string;
    };
    /**
     * Type of the MetricItem.
     */
    type: MetricItemType;
    /**
     * Timestamp of the recorded metric.
     */
    timeStamp: number;
    /**
     * value of the MetricItem.
     */
    value: number;
};

export enum MetricItemType {
    VALUE = 'value',
    COUNT = 'count',
    SUM = 'sum',
}

export enum MetricType {
    COUNTER = 'counter',
    GAUGE = 'gauge',
    HISTOGRAM = 'histogram',
    SUMMARY = 'summary',
}

export enum MetricUnit {
    MB = 'mb',
    KB = 'kb',
    PERCENTAGE = 'percentage',
    BIT_S = 'bit/s',
    BYTE_S = 'Byte/s',
}

export type SystemStatus = {
    /**
     * The health status of Xpanse api service.
     */
    healthStatus: HealthStatus;
};

export type ServiceTemplateRequestToReview = {
    /**
     * ID of the service template.
     */
    serviceTemplateId: string;
    /**
     * ID of the request history of the service template.
     */
    requestId: string;
    /**
     * Type of the request.
     */
    requestType: ServiceTemplateRequestType;
    /**
     * Type of the request.
     */
    ocl: Ocl;
    /**
     * Create time of the service template request.
     */
    createdTime: string;
    /**
     * Last update time of the service template request.
     */
    lastModifiedTime: string;
    requestSubmittedForReview?: boolean;
};

export type TokenResponse = {
    /**
     * An access_token as a JWT or opaque token.
     */
    access_token: string;
    /**
     * Type of the access_token.
     */
    token_type: string;
    /**
     * Number of second until the expiration of the access_token
     */
    expires_in: string;
    /**
     * An id_token of the authorized service user
     */
    id_token: string;
    /**
     * Scopes of the access_token.
     */
    scopes?: string;
};

export type ServiceChangeRequest = {
    /**
     * Id of the change request
     */
    changeId: string;
    /**
     * request parameters to be used to execute the change scripts. In case of Ansible, this will be used as extra vars.
     */
    serviceChangeParameters: {
        [key: string]: unknown;
    };
    /**
     * defines the ansible script information.
     */
    ansibleScriptConfig?: AnsibleScriptConfig;
    /**
     * Inventory information for Ansible script.
     */
    ansibleInventory?: {
        [key: string]: unknown;
    };
};

export type ManageFailedOrderData = {
    body?: never;
    path: {
        /**
         * ID of the workflow task that needs to be handled
         */
        taskId: string;
    };
    query: {
        /**
         * Controls if the order must be retried again or simply closed.
         */
        retryOrder: boolean;
    };
    url: '/xpanse/workflow/task/{taskId}';
};

export type ManageFailedOrderErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type ManageFailedOrderError = ManageFailedOrderErrors[keyof ManageFailedOrderErrors];

export type ManageFailedOrderResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type CompleteTaskData = {
    body: {
        [key: string]: unknown;
    };
    path: {
        /**
         * ID of the workflow task that needs to be handled
         */
        taskId: string;
    };
    query?: never;
    url: '/xpanse/workflow/complete/task/{taskId}';
};

export type CompleteTaskErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type CompleteTaskError = CompleteTaskErrors[keyof CompleteTaskErrors];

export type CompleteTaskResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeleteUserCloudCredentialData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The cloud service provider.
         */
        cspName: Csp;
        /**
         * The site of the provider.
         */
        siteName: string;
        /**
         * The type of credential.
         */
        type: CredentialType;
        /**
         * The name of credential.
         */
        name: string;
    };
    url: '/xpanse/user/credentials';
};

export type DeleteUserCloudCredentialErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteUserCloudCredentialError = DeleteUserCloudCredentialErrors[keyof DeleteUserCloudCredentialErrors];

export type DeleteUserCloudCredentialResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteUserCloudCredentialResponse =
    DeleteUserCloudCredentialResponses[keyof DeleteUserCloudCredentialResponses];

export type GetUserCloudCredentialsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The cloud service provider.
         */
        cspName?: Csp;
        /**
         * The type of credential.
         */
        type?: CredentialType;
    };
    url: '/xpanse/user/credentials';
};

export type GetUserCloudCredentialsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetUserCloudCredentialsError = GetUserCloudCredentialsErrors[keyof GetUserCloudCredentialsErrors];

export type GetUserCloudCredentialsResponses = {
    /**
     * OK
     */
    200: Array<AbstractCredentialInfo>;
};

export type GetUserCloudCredentialsResponse = GetUserCloudCredentialsResponses[keyof GetUserCloudCredentialsResponses];

export type AddUserCloudCredentialData = {
    body: CreateCredential;
    path?: never;
    query?: never;
    url: '/xpanse/user/credentials';
};

export type AddUserCloudCredentialErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type AddUserCloudCredentialError = AddUserCloudCredentialErrors[keyof AddUserCloudCredentialErrors];

export type AddUserCloudCredentialResponses = {
    /**
     * No Content
     */
    204: void;
};

export type AddUserCloudCredentialResponse = AddUserCloudCredentialResponses[keyof AddUserCloudCredentialResponses];

export type UpdateUserCloudCredentialData = {
    body: CreateCredential;
    path?: never;
    query?: never;
    url: '/xpanse/user/credentials';
};

export type UpdateUserCloudCredentialErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateUserCloudCredentialError = UpdateUserCloudCredentialErrors[keyof UpdateUserCloudCredentialErrors];

export type UpdateUserCloudCredentialResponses = {
    /**
     * No Content
     */
    204: void;
};

export type UpdateUserCloudCredentialResponse =
    UpdateUserCloudCredentialResponses[keyof UpdateUserCloudCredentialResponses];

export type StopServiceData = {
    body?: never;
    path: {
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/stop/{serviceId}';
};

export type StopServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type StopServiceError = StopServiceErrors[keyof StopServiceErrors];

export type StopServiceResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type StopServiceResponse = StopServiceResponses[keyof StopServiceResponses];

export type StartServiceData = {
    body?: never;
    path: {
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/start/{serviceId}';
};

export type StartServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type StartServiceError = StartServiceErrors[keyof StartServiceErrors];

export type StartServiceResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type StartServiceResponse = StartServiceResponses[keyof StartServiceResponses];

export type RestartServiceData = {
    body?: never;
    path: {
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/restart/{serviceId}';
};

export type RestartServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type RestartServiceError = RestartServiceErrors[keyof RestartServiceErrors];

export type RestartServiceResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type RestartServiceResponse = RestartServiceResponses[keyof RestartServiceResponses];

export type RecreateServiceData = {
    body?: never;
    path: {
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/recreate/{serviceId}';
};

export type RecreateServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type RecreateServiceError = RecreateServiceErrors[keyof RecreateServiceErrors];

export type RecreateServiceResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type RecreateServiceResponse = RecreateServiceResponses[keyof RecreateServiceResponses];

export type DeleteServiceObjectData = {
    body?: never;
    path: {
        /**
         * The id of the deployed service.
         */
        serviceId: string;
        /**
         * The id of the service object.
         */
        objectId: string;
    };
    query?: never;
    url: '/xpanse/services/object/{serviceId}/{objectId}';
};

export type DeleteServiceObjectErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteServiceObjectError = DeleteServiceObjectErrors[keyof DeleteServiceObjectErrors];

export type DeleteServiceObjectResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type DeleteServiceObjectResponse = DeleteServiceObjectResponses[keyof DeleteServiceObjectResponses];

export type UpdateServiceObjectData = {
    body: ServiceObjectRequest;
    path: {
        /**
         * The id of the deployed service.
         */
        serviceId: string;
        /**
         * The id of the service object.
         */
        objectId: string;
    };
    query?: never;
    url: '/xpanse/services/object/{serviceId}/{objectId}';
};

export type UpdateServiceObjectErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateServiceObjectError = UpdateServiceObjectErrors[keyof UpdateServiceObjectErrors];

export type UpdateServiceObjectResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type UpdateServiceObjectResponse = UpdateServiceObjectResponses[keyof UpdateServiceObjectResponses];

export type ModifyData = {
    body: ModifyRequest;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/modify/{serviceId}';
};

export type ModifyErrors = {
    400: OrderFailedErrorResponse;
    401: OrderFailedErrorResponse;
    403: OrderFailedErrorResponse;
    408: OrderFailedErrorResponse;
    422: OrderFailedErrorResponse;
    500: OrderFailedErrorResponse;
    502: OrderFailedErrorResponse;
};

export type ModifyError = ModifyErrors[keyof ModifyErrors];

export type ModifyResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type ModifyResponse = ModifyResponses[keyof ModifyResponses];

export type RedeployFailedDeploymentData = {
    body?: never;
    path: {
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/deploy/retry/{serviceId}';
};

export type RedeployFailedDeploymentErrors = {
    400: OrderFailedErrorResponse;
    401: OrderFailedErrorResponse;
    403: OrderFailedErrorResponse;
    408: OrderFailedErrorResponse;
    422: OrderFailedErrorResponse;
    500: OrderFailedErrorResponse;
    502: OrderFailedErrorResponse;
};

export type RedeployFailedDeploymentError = RedeployFailedDeploymentErrors[keyof RedeployFailedDeploymentErrors];

export type RedeployFailedDeploymentResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type RedeployFailedDeploymentResponse =
    RedeployFailedDeploymentResponses[keyof RedeployFailedDeploymentResponses];

export type ChangeServiceConfigurationData = {
    body: ServiceConfigurationUpdate;
    path: {
        /**
         * The id of the deployed service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/config/{serviceId}';
};

export type ChangeServiceConfigurationErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type ChangeServiceConfigurationError = ChangeServiceConfigurationErrors[keyof ChangeServiceConfigurationErrors];

export type ChangeServiceConfigurationResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type ChangeServiceConfigurationResponse =
    ChangeServiceConfigurationResponses[keyof ChangeServiceConfigurationResponses];

export type ChangeServiceLockConfigData = {
    body: ServiceLockConfig;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/changelock/{serviceId}';
};

export type ChangeServiceLockConfigErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type ChangeServiceLockConfigError = ChangeServiceLockConfigErrors[keyof ChangeServiceLockConfigErrors];

export type ChangeServiceLockConfigResponses = {
    /**
     * OK
     */
    200: ServiceOrder;
};

export type ChangeServiceLockConfigResponse = ChangeServiceLockConfigResponses[keyof ChangeServiceLockConfigResponses];

export type CreateServiceActionData = {
    body: ServiceActionRequest;
    path: {
        /**
         * The id of the deployed service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/action/{serviceId}';
};

export type CreateServiceActionErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type CreateServiceActionError = CreateServiceActionErrors[keyof CreateServiceActionErrors];

export type CreateServiceActionResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type CreateServiceActionResponse = CreateServiceActionResponses[keyof CreateServiceActionResponses];

export type DeleteServiceTemplateData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/service_templates/{serviceTemplateId}';
};

export type DeleteServiceTemplateErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteServiceTemplateError = DeleteServiceTemplateErrors[keyof DeleteServiceTemplateErrors];

export type DeleteServiceTemplateResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteServiceTemplateResponse = DeleteServiceTemplateResponses[keyof DeleteServiceTemplateResponses];

export type GetServiceTemplateDetailsByIdData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/service_templates/{serviceTemplateId}';
};

export type GetServiceTemplateDetailsByIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServiceTemplateDetailsByIdError =
    GetServiceTemplateDetailsByIdErrors[keyof GetServiceTemplateDetailsByIdErrors];

export type GetServiceTemplateDetailsByIdResponses = {
    /**
     * OK
     */
    200: ServiceTemplateDetailVo;
};

export type GetServiceTemplateDetailsByIdResponse =
    GetServiceTemplateDetailsByIdResponses[keyof GetServiceTemplateDetailsByIdResponses];

export type UpdateData = {
    body: Ocl;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query: {
        /**
         * If true, the old service template is also removed from catalog until the updated one is reviewed and approved.
         */
        isUnpublishUntilApproved: boolean;
    };
    url: '/xpanse/service_templates/{serviceTemplateId}';
};

export type UpdateErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateError = UpdateErrors[keyof UpdateErrors];

export type UpdateResponses = {
    /**
     * OK
     */
    200: ServiceTemplateRequestInfo;
};

export type UpdateResponse = UpdateResponses[keyof UpdateResponses];

export type UnpublishData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/service_templates/unpublish/{serviceTemplateId}';
};

export type UnpublishErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UnpublishError = UnpublishErrors[keyof UnpublishErrors];

export type UnpublishResponses = {
    /**
     * OK
     */
    200: ServiceTemplateRequestInfo;
};

export type UnpublishResponse = UnpublishResponses[keyof UnpublishResponses];

export type CancelServiceTemplateRequestByRequestIdData = {
    body?: never;
    path: {
        /**
         * id of service template request
         */
        requestId: string;
    };
    query?: never;
    url: '/xpanse/service_templates/requests/cancel/{requestId}';
};

export type CancelServiceTemplateRequestByRequestIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type CancelServiceTemplateRequestByRequestIdError =
    CancelServiceTemplateRequestByRequestIdErrors[keyof CancelServiceTemplateRequestByRequestIdErrors];

export type CancelServiceTemplateRequestByRequestIdResponses = {
    /**
     * No Content
     */
    204: void;
};

export type CancelServiceTemplateRequestByRequestIdResponse =
    CancelServiceTemplateRequestByRequestIdResponses[keyof CancelServiceTemplateRequestByRequestIdResponses];

export type RepublishData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/service_templates/republish/{serviceTemplateId}';
};

export type RepublishErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type RepublishError = RepublishErrors[keyof RepublishErrors];

export type RepublishResponses = {
    /**
     * OK
     */
    200: ServiceTemplateRequestInfo;
};

export type RepublishResponse = RepublishResponses[keyof RepublishResponses];

export type FetchUpdateData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query: {
        /**
         * If true, the old service template is also removed from catalog until the updated one is reviewed and approved.
         */
        isUnpublishUntilApproved: boolean;
        /**
         * URL of Ocl file
         */
        oclLocation: string;
    };
    url: '/xpanse/service_templates/file/{serviceTemplateId}';
};

export type FetchUpdateErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type FetchUpdateError = FetchUpdateErrors[keyof FetchUpdateErrors];

export type FetchUpdateResponses = {
    /**
     * OK
     */
    200: ServiceTemplateRequestInfo;
};

export type FetchUpdateResponse = FetchUpdateResponses[keyof FetchUpdateResponses];

export type DeleteServicePolicyData = {
    body?: never;
    path: {
        servicePolicyId: string;
    };
    query?: never;
    url: '/xpanse/service/policies/{servicePolicyId}';
};

export type DeleteServicePolicyErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteServicePolicyError = DeleteServicePolicyErrors[keyof DeleteServicePolicyErrors];

export type DeleteServicePolicyResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteServicePolicyResponse = DeleteServicePolicyResponses[keyof DeleteServicePolicyResponses];

export type GetServicePolicyDetailsData = {
    body?: never;
    path: {
        servicePolicyId: string;
    };
    query?: never;
    url: '/xpanse/service/policies/{servicePolicyId}';
};

export type GetServicePolicyDetailsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServicePolicyDetailsError = GetServicePolicyDetailsErrors[keyof GetServicePolicyDetailsErrors];

export type GetServicePolicyDetailsResponses = {
    /**
     * OK
     */
    200: ServicePolicy;
};

export type GetServicePolicyDetailsResponse = GetServicePolicyDetailsResponses[keyof GetServicePolicyDetailsResponses];

export type UpdateServicePolicyData = {
    body: ServicePolicyUpdateRequest;
    path: {
        /**
         * ID of the policy to be updated
         */
        servicePolicyId: string;
    };
    query?: never;
    url: '/xpanse/service/policies/{servicePolicyId}';
};

export type UpdateServicePolicyErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateServicePolicyError = UpdateServicePolicyErrors[keyof UpdateServicePolicyErrors];

export type UpdateServicePolicyResponses = {
    /**
     * OK
     */
    200: ServicePolicy;
};

export type UpdateServicePolicyResponse = UpdateServicePolicyResponses[keyof UpdateServicePolicyResponses];

export type DeleteUserPolicyData = {
    body?: never;
    path: {
        /**
         * id of the policy created by user to be updated
         */
        userPolicyId: string;
    };
    query?: never;
    url: '/xpanse/policies/{userPolicyId}';
};

export type DeleteUserPolicyErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteUserPolicyError = DeleteUserPolicyErrors[keyof DeleteUserPolicyErrors];

export type DeleteUserPolicyResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteUserPolicyResponse = DeleteUserPolicyResponses[keyof DeleteUserPolicyResponses];

export type GetPolicyDetailsData = {
    body?: never;
    path: {
        userPolicyId: string;
    };
    query?: never;
    url: '/xpanse/policies/{userPolicyId}';
};

export type GetPolicyDetailsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetPolicyDetailsError = GetPolicyDetailsErrors[keyof GetPolicyDetailsErrors];

export type GetPolicyDetailsResponses = {
    /**
     * OK
     */
    200: UserPolicy;
};

export type GetPolicyDetailsResponse = GetPolicyDetailsResponses[keyof GetPolicyDetailsResponses];

export type UpdateUserPolicyData = {
    body: UserPolicyUpdateRequest;
    path: {
        /**
         * id of the policy created by user to be updated
         */
        userPolicyId: string;
    };
    query?: never;
    url: '/xpanse/policies/{userPolicyId}';
};

export type UpdateUserPolicyErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateUserPolicyError = UpdateUserPolicyErrors[keyof UpdateUserPolicyErrors];

export type UpdateUserPolicyResponses = {
    /**
     * OK
     */
    200: UserPolicy;
};

export type UpdateUserPolicyResponse = UpdateUserPolicyResponses[keyof UpdateUserPolicyResponses];

export type DeleteIsvCloudCredentialData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The cloud service provider.
         */
        cspName: Csp;
        /**
         * The site of the provider.
         */
        siteName: string;
        /**
         * The type of credential.
         */
        type: CredentialType;
        /**
         * The name of credential.
         */
        name: string;
    };
    url: '/xpanse/isv/credentials';
};

export type DeleteIsvCloudCredentialErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteIsvCloudCredentialError = DeleteIsvCloudCredentialErrors[keyof DeleteIsvCloudCredentialErrors];

export type DeleteIsvCloudCredentialResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteIsvCloudCredentialResponse =
    DeleteIsvCloudCredentialResponses[keyof DeleteIsvCloudCredentialResponses];

export type GetIsvCloudCredentialsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The cloud service provider.
         */
        cspName?: Csp;
        /**
         * The type of credential.
         */
        type?: CredentialType;
    };
    url: '/xpanse/isv/credentials';
};

export type GetIsvCloudCredentialsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetIsvCloudCredentialsError = GetIsvCloudCredentialsErrors[keyof GetIsvCloudCredentialsErrors];

export type GetIsvCloudCredentialsResponses = {
    /**
     * OK
     */
    200: Array<AbstractCredentialInfo>;
};

export type GetIsvCloudCredentialsResponse = GetIsvCloudCredentialsResponses[keyof GetIsvCloudCredentialsResponses];

export type AddIsvCloudCredentialData = {
    body: CreateCredential;
    path?: never;
    query?: never;
    url: '/xpanse/isv/credentials';
};

export type AddIsvCloudCredentialErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type AddIsvCloudCredentialError = AddIsvCloudCredentialErrors[keyof AddIsvCloudCredentialErrors];

export type AddIsvCloudCredentialResponses = {
    /**
     * No Content
     */
    204: void;
};

export type AddIsvCloudCredentialResponse = AddIsvCloudCredentialResponses[keyof AddIsvCloudCredentialResponses];

export type UpdateIsvCloudCredentialData = {
    body: CreateCredential;
    path?: never;
    query?: never;
    url: '/xpanse/isv/credentials';
};

export type UpdateIsvCloudCredentialErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateIsvCloudCredentialError = UpdateIsvCloudCredentialErrors[keyof UpdateIsvCloudCredentialErrors];

export type UpdateIsvCloudCredentialResponses = {
    /**
     * No Content
     */
    204: void;
};

export type UpdateIsvCloudCredentialResponse =
    UpdateIsvCloudCredentialResponses[keyof UpdateIsvCloudCredentialResponses];

export type ReviewServiceTemplateRequestData = {
    body: ReviewServiceTemplateRequest;
    path: {
        /**
         * id of service template request
         */
        requestId: string;
    };
    query?: never;
    url: '/xpanse/csp/service_templates/requests/review/{requestId}';
};

export type ReviewServiceTemplateRequestErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type ReviewServiceTemplateRequestError =
    ReviewServiceTemplateRequestErrors[keyof ReviewServiceTemplateRequestErrors];

export type ReviewServiceTemplateRequestResponses = {
    /**
     * No Content
     */
    204: void;
};

export type ReviewServiceTemplateRequestResponse =
    ReviewServiceTemplateRequestResponses[keyof ReviewServiceTemplateRequestResponses];

export type UpdateServiceChangeResultData = {
    body: ServiceChangeResult;
    path: {
        /**
         * id of the update request.
         */
        changeId: string;
    };
    query?: never;
    url: '/agent/xpanse/update/status/{changeId}';
};

export type UpdateServiceChangeResultErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type UpdateServiceChangeResultError = UpdateServiceChangeResultErrors[keyof UpdateServiceChangeResultErrors];

export type UpdateServiceChangeResultResponses = {
    /**
     * No Content
     */
    204: void;
};

export type UpdateServiceChangeResultResponse =
    UpdateServiceChangeResultResponses[keyof UpdateServiceChangeResultResponses];

export type GetAllDeployedServicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the cloud service provider
         */
        cspName?: Csp;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * deployment state of the service
         */
        serviceState?: ServiceDeploymentState;
    };
    url: '/xpanse/services';
};

export type GetAllDeployedServicesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllDeployedServicesError = GetAllDeployedServicesErrors[keyof GetAllDeployedServicesErrors];

export type GetAllDeployedServicesResponses = {
    /**
     * OK
     */
    200: Array<DeployedService>;
};

export type GetAllDeployedServicesResponse = GetAllDeployedServicesResponses[keyof GetAllDeployedServicesResponses];

export type DeployData = {
    body: DeployRequest;
    path?: never;
    query?: never;
    url: '/xpanse/services';
};

export type DeployErrors = {
    400: OrderFailedErrorResponse;
    401: OrderFailedErrorResponse;
    403: OrderFailedErrorResponse;
    408: OrderFailedErrorResponse;
    422: OrderFailedErrorResponse;
    500: OrderFailedErrorResponse;
    502: OrderFailedErrorResponse;
};

export type DeployError = DeployErrors[keyof DeployErrors];

export type DeployResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type DeployResponse = DeployResponses[keyof DeployResponses];

export type PortData = {
    body: ServicePortingRequest;
    path?: never;
    query?: never;
    url: '/xpanse/services/porting';
};

export type PortErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type PortError = PortErrors[keyof PortErrors];

export type PortResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type PortResponse = PortResponses[keyof PortResponses];

export type CreateServiceObjectData = {
    body: ServiceObjectRequest;
    path: {
        /**
         * The id of the deployed service.
         */
        serviceId: string;
        /**
         * The action type to the service object.
         */
        objectType: string;
    };
    query?: never;
    url: '/xpanse/services/object/{serviceId}/{objectType}';
};

export type CreateServiceObjectErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type CreateServiceObjectError = CreateServiceObjectErrors[keyof CreateServiceObjectErrors];

export type CreateServiceObjectResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type CreateServiceObjectResponse = CreateServiceObjectResponses[keyof CreateServiceObjectResponses];

export type GetAllServiceTemplatesByIsvData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the cloud service provider
         */
        cspName?: Csp;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * who hosts ths cloud resources
         */
        serviceHostingType?: ServiceHostingType;
        /**
         * state of service template registration
         */
        serviceTemplateRegistrationState?: ServiceTemplateRegistrationState;
        /**
         * is available in catalog
         */
        isAvailableInCatalog?: boolean;
        /**
         * is any request in review progress
         */
        isReviewInProgress?: boolean;
    };
    url: '/xpanse/service_templates';
};

export type GetAllServiceTemplatesByIsvErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllServiceTemplatesByIsvError =
    GetAllServiceTemplatesByIsvErrors[keyof GetAllServiceTemplatesByIsvErrors];

export type GetAllServiceTemplatesByIsvResponses = {
    /**
     * OK
     */
    200: Array<ServiceTemplateDetailVo>;
};

export type GetAllServiceTemplatesByIsvResponse =
    GetAllServiceTemplatesByIsvResponses[keyof GetAllServiceTemplatesByIsvResponses];

export type RegisterData = {
    body: Ocl;
    path?: never;
    query?: never;
    url: '/xpanse/service_templates';
};

export type RegisterErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type RegisterError = RegisterErrors[keyof RegisterErrors];

export type RegisterResponses = {
    /**
     * OK
     */
    200: ServiceTemplateRequestInfo;
};

export type RegisterResponse = RegisterResponses[keyof RegisterResponses];

export type FetchData = {
    body?: never;
    path?: never;
    query: {
        /**
         * URL of Ocl file
         */
        oclLocation: string;
    };
    url: '/xpanse/service_templates/file';
};

export type FetchErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type FetchError = FetchErrors[keyof FetchErrors];

export type FetchResponses = {
    /**
     * OK
     */
    200: ServiceTemplateRequestInfo;
};

export type FetchResponse = FetchResponses[keyof FetchResponses];

export type GetAllServicePoliciesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The id of service template which the policy belongs to.
         */
        serviceTemplateId: string;
    };
    url: '/xpanse/service/policies';
};

export type GetAllServicePoliciesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllServicePoliciesError = GetAllServicePoliciesErrors[keyof GetAllServicePoliciesErrors];

export type GetAllServicePoliciesResponses = {
    /**
     * OK
     */
    200: Array<ServicePolicy>;
};

export type GetAllServicePoliciesResponse = GetAllServicePoliciesResponses[keyof GetAllServicePoliciesResponses];

export type AddServicePolicyData = {
    body: ServicePolicyCreateRequest;
    path?: never;
    query?: never;
    url: '/xpanse/service/policies';
};

export type AddServicePolicyErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type AddServicePolicyError = AddServicePolicyErrors[keyof AddServicePolicyErrors];

export type AddServicePolicyResponses = {
    /**
     * OK
     */
    200: ServicePolicy;
};

export type AddServicePolicyResponse = AddServicePolicyResponses[keyof AddServicePolicyResponses];

export type GetAllUserPoliciesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Name of csp which the policy belongs to.
         */
        cspName?: Csp;
        /**
         * Is the policy enabled.
         */
        enabled?: boolean;
    };
    url: '/xpanse/policies';
};

export type GetAllUserPoliciesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllUserPoliciesError = GetAllUserPoliciesErrors[keyof GetAllUserPoliciesErrors];

export type GetAllUserPoliciesResponses = {
    /**
     * OK
     */
    200: Array<UserPolicy>;
};

export type GetAllUserPoliciesResponse = GetAllUserPoliciesResponses[keyof GetAllUserPoliciesResponses];

export type AddUserPolicyData = {
    body: UserPolicyCreateRequest;
    path?: never;
    query?: never;
    url: '/xpanse/policies';
};

export type AddUserPolicyErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type AddUserPolicyError = AddUserPolicyErrors[keyof AddUserPolicyErrors];

export type AddUserPolicyResponses = {
    /**
     * OK
     */
    200: UserPolicy;
};

export type AddUserPolicyResponse = AddUserPolicyResponses[keyof AddUserPolicyResponses];

export type QueryTasksData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * the status of task
         */
        status?: WorkFlowTaskStatus;
    };
    url: '/xpanse/workflow/tasks';
};

export type QueryTasksErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type QueryTasksError = QueryTasksErrors[keyof QueryTasksErrors];

export type QueryTasksResponses = {
    /**
     * OK
     */
    200: Array<WorkFlowTask>;
};

export type QueryTasksResponse = QueryTasksResponses[keyof QueryTasksResponses];

export type StackHealthStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/xpanse/stack/health';
};

export type StackHealthStatusErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type StackHealthStatusError = StackHealthStatusErrors[keyof StackHealthStatusErrors];

export type StackHealthStatusResponses = {
    /**
     * OK
     */
    200: StackStatus;
};

export type StackHealthStatusResponse = StackHealthStatusResponses[keyof StackHealthStatusResponses];

export type GetOrderableServiceDetailsByServiceIdData = {
    body?: never;
    path: {
        /**
         * The id of deployed service.
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/{serviceId}/service_template';
};

export type GetOrderableServiceDetailsByServiceIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetOrderableServiceDetailsByServiceIdError =
    GetOrderableServiceDetailsByServiceIdErrors[keyof GetOrderableServiceDetailsByServiceIdErrors];

export type GetOrderableServiceDetailsByServiceIdResponses = {
    /**
     * OK
     */
    200: UserOrderableServiceVo;
};

export type GetOrderableServiceDetailsByServiceIdResponse =
    GetOrderableServiceDetailsByServiceIdResponses[keyof GetOrderableServiceDetailsByServiceIdResponses];

export type GetComputeResourceInventoryOfServiceData = {
    body?: never;
    path: {
        /**
         * Id of the deployed service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/{serviceId}/resources/compute';
};

export type GetComputeResourceInventoryOfServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetComputeResourceInventoryOfServiceError =
    GetComputeResourceInventoryOfServiceErrors[keyof GetComputeResourceInventoryOfServiceErrors];

export type GetComputeResourceInventoryOfServiceResponses = {
    /**
     * OK
     */
    200: Array<DeployResource>;
};

export type GetComputeResourceInventoryOfServiceResponse =
    GetComputeResourceInventoryOfServiceResponses[keyof GetComputeResourceInventoryOfServiceResponses];

export type DeleteOrdersByServiceIdData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/{serviceId}/orders';
};

export type DeleteOrdersByServiceIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteOrdersByServiceIdError = DeleteOrdersByServiceIdErrors[keyof DeleteOrdersByServiceIdErrors];

export type DeleteOrdersByServiceIdResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteOrdersByServiceIdResponse = DeleteOrdersByServiceIdResponses[keyof DeleteOrdersByServiceIdResponses];

export type GetAllOrdersByServiceIdData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: {
        /**
         * Task type of the service order.
         */
        taskType?: ServiceOrderType;
        /**
         * Task status of the service order
         */
        orderStatus?: OrderStatus;
    };
    url: '/xpanse/services/{serviceId}/orders';
};

export type GetAllOrdersByServiceIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllOrdersByServiceIdError = GetAllOrdersByServiceIdErrors[keyof GetAllOrdersByServiceIdErrors];

export type GetAllOrdersByServiceIdResponses = {
    /**
     * OK
     */
    200: Array<ServiceOrderDetails>;
};

export type GetAllOrdersByServiceIdResponse = GetAllOrdersByServiceIdResponses[keyof GetAllOrdersByServiceIdResponses];

export type GetLatestServiceDeploymentStatusData = {
    body?: never;
    path: {
        /**
         * ID of the service
         */
        serviceId: string;
    };
    query?: {
        /**
         * Last known service status to client. When provided, the service will wait for a configured period time until to see if there is a change to the last known state.
         */
        lastKnownServiceDeploymentState?: ServiceDeploymentState;
    };
    url: '/xpanse/services/{serviceId}/deployment/status';
};

export type GetLatestServiceDeploymentStatusErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetLatestServiceDeploymentStatusError =
    GetLatestServiceDeploymentStatusErrors[keyof GetLatestServiceDeploymentStatusErrors];

export type GetLatestServiceDeploymentStatusResponses = {
    /**
     * OK
     */
    200: DeploymentStatusUpdate;
};

export type GetLatestServiceDeploymentStatusResponse =
    GetLatestServiceDeploymentStatusResponses[keyof GetLatestServiceDeploymentStatusResponses];

export type DeleteOrderByOrderIdData = {
    body?: never;
    path: {
        /**
         * Id of the service order
         */
        orderId: string;
    };
    query?: never;
    url: '/xpanse/services/orders/{orderId}';
};

export type DeleteOrderByOrderIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type DeleteOrderByOrderIdError = DeleteOrderByOrderIdErrors[keyof DeleteOrderByOrderIdErrors];

export type DeleteOrderByOrderIdResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteOrderByOrderIdResponse = DeleteOrderByOrderIdResponses[keyof DeleteOrderByOrderIdResponses];

export type GetOrderDetailsByOrderIdData = {
    body?: never;
    path: {
        /**
         * Id of the service order
         */
        orderId: string;
    };
    query?: never;
    url: '/xpanse/services/orders/{orderId}';
};

export type GetOrderDetailsByOrderIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetOrderDetailsByOrderIdError = GetOrderDetailsByOrderIdErrors[keyof GetOrderDetailsByOrderIdErrors];

export type GetOrderDetailsByOrderIdResponses = {
    /**
     * OK
     */
    200: ServiceOrderDetails;
};

export type GetOrderDetailsByOrderIdResponse =
    GetOrderDetailsByOrderIdResponses[keyof GetOrderDetailsByOrderIdResponses];

export type GetLatestServiceOrderStatusData = {
    body?: never;
    path: {
        /**
         * Id of the service order
         */
        orderId: string;
    };
    query?: {
        /**
         * Last known service order task status to client. When provided, the service will wait for a configured period time until to see if there is a change to the last known state.
         */
        lastKnownServiceDeploymentState?: OrderStatus;
    };
    url: '/xpanse/services/orders/{orderId}/status';
};

export type GetLatestServiceOrderStatusErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetLatestServiceOrderStatusError =
    GetLatestServiceOrderStatusErrors[keyof GetLatestServiceOrderStatusErrors];

export type GetLatestServiceOrderStatusResponses = {
    /**
     * OK
     */
    200: ServiceOrderStatusUpdate;
};

export type GetLatestServiceOrderStatusResponse =
    GetLatestServiceOrderStatusResponses[keyof GetLatestServiceOrderStatusResponses];

export type GetObjectsByServiceIdData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/objects/{serviceId}';
};

export type GetObjectsByServiceIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetObjectsByServiceIdError = GetObjectsByServiceIdErrors[keyof GetObjectsByServiceIdErrors];

export type GetObjectsByServiceIdResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: Array<ServiceObjectDetails>;
    };
};

export type GetObjectsByServiceIdResponse = GetObjectsByServiceIdResponses[keyof GetObjectsByServiceIdResponses];

export type GetAllDeployedServicesByIsvData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the cloud service provider
         */
        cspName?: Csp;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * deployment state of the service
         */
        serviceState?: ServiceDeploymentState;
    };
    url: '/xpanse/services/isv';
};

export type GetAllDeployedServicesByIsvErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllDeployedServicesByIsvError =
    GetAllDeployedServicesByIsvErrors[keyof GetAllDeployedServicesByIsvErrors];

export type GetAllDeployedServicesByIsvResponses = {
    /**
     * OK
     */
    200: Array<DeployedService>;
};

export type GetAllDeployedServicesByIsvResponse =
    GetAllDeployedServicesByIsvResponses[keyof GetAllDeployedServicesByIsvResponses];

export type GetServiceDetailsByIdForIsvData = {
    body?: never;
    path: {
        /**
         * Id of deployed service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/isv/details/vendor_hosted/{serviceId}';
};

export type GetServiceDetailsByIdForIsvErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServiceDetailsByIdForIsvError =
    GetServiceDetailsByIdForIsvErrors[keyof GetServiceDetailsByIdForIsvErrors];

export type GetServiceDetailsByIdForIsvResponses = {
    /**
     * OK
     */
    200: DeployedServiceDetails;
};

export type GetServiceDetailsByIdForIsvResponse =
    GetServiceDetailsByIdForIsvResponses[keyof GetServiceDetailsByIdForIsvResponses];

export type GetAllDeployedServicesWithDetailsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the cloud service provider
         */
        cspName?: Csp;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * deployment state of the service
         */
        serviceState?: ServiceDeploymentState;
    };
    url: '/xpanse/services/details';
};

export type GetAllDeployedServicesWithDetailsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllDeployedServicesWithDetailsError =
    GetAllDeployedServicesWithDetailsErrors[keyof GetAllDeployedServicesWithDetailsErrors];

export type GetAllDeployedServicesWithDetailsResponses = {
    /**
     * OK
     */
    200: Array<DeployedService>;
};

export type GetAllDeployedServicesWithDetailsResponse =
    GetAllDeployedServicesWithDetailsResponses[keyof GetAllDeployedServicesWithDetailsResponses];

export type GetVendorHostedServiceDetailsByIdData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/details/vendor_hosted/{serviceId}';
};

export type GetVendorHostedServiceDetailsByIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetVendorHostedServiceDetailsByIdError =
    GetVendorHostedServiceDetailsByIdErrors[keyof GetVendorHostedServiceDetailsByIdErrors];

export type GetVendorHostedServiceDetailsByIdResponses = {
    /**
     * OK
     */
    200: VendorHostedDeployedServiceDetails;
};

export type GetVendorHostedServiceDetailsByIdResponse =
    GetVendorHostedServiceDetailsByIdResponses[keyof GetVendorHostedServiceDetailsByIdResponses];

export type GetSelfHostedServiceDetailsByIdData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/details/self_hosted/{serviceId}';
};

export type GetSelfHostedServiceDetailsByIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetSelfHostedServiceDetailsByIdError =
    GetSelfHostedServiceDetailsByIdErrors[keyof GetSelfHostedServiceDetailsByIdErrors];

export type GetSelfHostedServiceDetailsByIdResponses = {
    /**
     * OK
     */
    200: DeployedServiceDetails;
};

export type GetSelfHostedServiceDetailsByIdResponse =
    GetSelfHostedServiceDetailsByIdResponses[keyof GetSelfHostedServiceDetailsByIdResponses];

export type GetAllDeployedServicesByCspData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * deployment state of the service
         */
        serviceState?: ServiceDeploymentState;
    };
    url: '/xpanse/services/csp';
};

export type GetAllDeployedServicesByCspErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllDeployedServicesByCspError =
    GetAllDeployedServicesByCspErrors[keyof GetAllDeployedServicesByCspErrors];

export type GetAllDeployedServicesByCspResponses = {
    /**
     * OK
     */
    200: Array<DeployedService>;
};

export type GetAllDeployedServicesByCspResponse =
    GetAllDeployedServicesByCspResponses[keyof GetAllDeployedServicesByCspResponses];

export type GetServiceChangeRequestDetailsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Id of the deployed service
         */
        serviceId: string;
        /**
         * id of the service order
         */
        orderId?: string;
        /**
         * name of the service resource
         */
        resourceName?: string;
        /**
         * Manager of the service configuration parameter.
         */
        configManager?: string;
        /**
         * Status of the service configuration
         */
        status?: ServiceChangeStatus;
    };
    url: '/xpanse/services/change/requests';
};

export type GetServiceChangeRequestDetailsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServiceChangeRequestDetailsError =
    GetServiceChangeRequestDetailsErrors[keyof GetServiceChangeRequestDetailsErrors];

export type GetServiceChangeRequestDetailsResponses = {
    /**
     * OK
     */
    200: Array<ServiceChangeOrderDetails>;
};

export type GetServiceChangeRequestDetailsResponse =
    GetServiceChangeRequestDetailsResponses[keyof GetServiceChangeRequestDetailsResponses];

export type GetServiceTemplateRequestHistoryForIsvData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: {
        /**
         * type of service template request
         */
        requestType?: ServiceTemplateRequestType;
        /**
         * status of service template request
         */
        requestStatus?: ServiceTemplateRequestStatus;
    };
    url: '/xpanse/service_templates/{serviceTemplateId}/requests';
};

export type GetServiceTemplateRequestHistoryForIsvErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServiceTemplateRequestHistoryForIsvError =
    GetServiceTemplateRequestHistoryForIsvErrors[keyof GetServiceTemplateRequestHistoryForIsvErrors];

export type GetServiceTemplateRequestHistoryForIsvResponses = {
    /**
     * OK
     */
    200: Array<ServiceTemplateRequestHistory>;
};

export type GetServiceTemplateRequestHistoryForIsvResponse =
    GetServiceTemplateRequestHistoryForIsvResponses[keyof GetServiceTemplateRequestHistoryForIsvResponses];

export type GetRequestedServiceTemplateByRequestIdData = {
    body?: never;
    path: {
        /**
         * id of service template request
         */
        requestId: string;
    };
    query?: never;
    url: '/xpanse/service_templates/requests/{requestId}';
};

export type GetRequestedServiceTemplateByRequestIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetRequestedServiceTemplateByRequestIdError =
    GetRequestedServiceTemplateByRequestIdErrors[keyof GetRequestedServiceTemplateByRequestIdErrors];

export type GetRequestedServiceTemplateByRequestIdResponses = {
    /**
     * OK
     */
    200: Ocl;
};

export type GetRequestedServiceTemplateByRequestIdResponse =
    GetRequestedServiceTemplateByRequestIdResponses[keyof GetRequestedServiceTemplateByRequestIdResponses];

export type GetCurrentConfigurationOfServiceData = {
    body?: never;
    path: {
        /**
         * The id of the deployed service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/service/current/config/{serviceId}';
};

export type GetCurrentConfigurationOfServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetCurrentConfigurationOfServiceError =
    GetCurrentConfigurationOfServiceErrors[keyof GetCurrentConfigurationOfServiceErrors];

export type GetCurrentConfigurationOfServiceResponses = {
    /**
     * OK
     */
    200: ServiceConfigurationDetails;
};

export type GetCurrentConfigurationOfServiceResponse =
    GetCurrentConfigurationOfServiceResponses[keyof GetCurrentConfigurationOfServiceResponses];

export type GetServicePriceByFlavorData = {
    body?: never;
    path: {
        /**
         * id of the service template
         */
        serviceTemplateId: string;
        /**
         * region name of the service
         */
        regionName: string;
        /**
         * site name of the region belongs to
         */
        siteName: string;
        /**
         * mode of billing
         */
        billingMode: BillingMode;
        /**
         * flavor name of the service
         */
        flavorName: string;
    };
    query?: never;
    url: '/xpanse/pricing/{serviceTemplateId}/{regionName}/{siteName}/{billingMode}/{flavorName}';
};

export type GetServicePriceByFlavorErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServicePriceByFlavorError = GetServicePriceByFlavorErrors[keyof GetServicePriceByFlavorErrors];

export type GetServicePriceByFlavorResponses = {
    /**
     * OK
     */
    200: FlavorPriceResult;
};

export type GetServicePriceByFlavorResponse = GetServicePriceByFlavorResponses[keyof GetServicePriceByFlavorResponses];

export type GetPricesByServiceData = {
    body?: never;
    path: {
        /**
         * id of the service template
         */
        serviceTemplateId: string;
        /**
         * region name of the service
         */
        regionName: string;
        /**
         * site name of the region belongs to
         */
        siteName: string;
        /**
         * mode of billing
         */
        billingMode: BillingMode;
    };
    query?: never;
    url: '/xpanse/pricing/service/{serviceTemplateId}/{regionName}/{siteName}/{billingMode}';
};

export type GetPricesByServiceErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetPricesByServiceError = GetPricesByServiceErrors[keyof GetPricesByServiceErrors];

export type GetPricesByServiceResponses = {
    /**
     * OK
     */
    200: Array<FlavorPriceResult>;
};

export type GetPricesByServiceResponse = GetPricesByServiceResponses[keyof GetPricesByServiceResponses];

export type GetMetricsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Id of the deployed service
         */
        serviceId: string;
        /**
         * Id of resource in the deployed service
         */
        resourceId?: string;
        /**
         * Types of the monitor resource.
         */
        monitorResourceType?: MonitorResourceType;
        /**
         * Start UNIX timestamp in milliseconds. If no value filled,the default value is the UNIX timestamp in milliseconds of the five minutes ago.
         */
        from?: number;
        /**
         * End UNIX timestamp in milliseconds. If no value filled,the default value is the UNIX timestamp in milliseconds of the current time.
         */
        to?: number;
        /**
         * Return metrics collected in provided time interval. This depends on how the source systems have generated/collected metrics.
         */
        granularity?: number;
        /**
         * Returns only the last known metric. When this parameter is set then all other query parameters are ignored.
         */
        onlyLastKnownMetric?: boolean;
    };
    url: '/xpanse/metrics';
};

export type GetMetricsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetMetricsError = GetMetricsErrors[keyof GetMetricsErrors];

export type GetMetricsResponses = {
    /**
     * OK
     */
    200: Array<Metric>;
};

export type GetMetricsResponse = GetMetricsResponses[keyof GetMetricsResponses];

export type HealthCheckData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/xpanse/health';
};

export type HealthCheckErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type HealthCheckError = HealthCheckErrors[keyof HealthCheckErrors];

export type HealthCheckResponses = {
    /**
     * OK
     */
    200: SystemStatus;
};

export type HealthCheckResponse = HealthCheckResponses[keyof HealthCheckResponses];

export type GetSitesOfCspData = {
    body?: never;
    path: {
        /**
         * The cloud service provider
         */
        cspName: Csp;
    };
    query?: never;
    url: '/xpanse/csps/{cspName}/sites';
};

export type GetSitesOfCspErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetSitesOfCspError = GetSitesOfCspErrors[keyof GetSitesOfCspErrors];

export type GetSitesOfCspResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type GetSitesOfCspResponse = GetSitesOfCspResponses[keyof GetSitesOfCspResponses];

export type GetActiveCspsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/xpanse/csps/active';
};

export type GetActiveCspsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetActiveCspsError = GetActiveCspsErrors[keyof GetActiveCspsErrors];

export type GetActiveCspsResponses = {
    /**
     * OK
     */
    200: Array<Csp>;
};

export type GetActiveCspsResponse = GetActiveCspsResponses[keyof GetActiveCspsResponses];

export type GetAllServiceTemplatesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * who hosts ths cloud resources
         */
        serviceHostingType?: ServiceHostingType;
        /**
         * state of service template registration
         */
        serviceTemplateRegistrationState?: ServiceTemplateRegistrationState;
        /**
         * is available in catalog
         */
        isAvailableInCatalog?: boolean;
        /**
         * is any request in review progress
         */
        isReviewInProgress?: boolean;
    };
    url: '/xpanse/csp/service_templates';
};

export type GetAllServiceTemplatesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAllServiceTemplatesError = GetAllServiceTemplatesErrors[keyof GetAllServiceTemplatesErrors];

export type GetAllServiceTemplatesResponses = {
    /**
     * OK
     */
    200: Array<ServiceTemplateDetailVo>;
};

export type GetAllServiceTemplatesResponse = GetAllServiceTemplatesResponses[keyof GetAllServiceTemplatesResponses];

export type GetServiceTemplateDetailsData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/csp/service_templates/{serviceTemplateId}';
};

export type GetServiceTemplateDetailsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServiceTemplateDetailsError = GetServiceTemplateDetailsErrors[keyof GetServiceTemplateDetailsErrors];

export type GetServiceTemplateDetailsResponses = {
    /**
     * OK
     */
    200: ServiceTemplateDetailVo;
};

export type GetServiceTemplateDetailsResponse =
    GetServiceTemplateDetailsResponses[keyof GetServiceTemplateDetailsResponses];

export type GetServiceTemplateRequestHistoryForCspData = {
    body?: never;
    path: {
        /**
         * id of service template
         */
        serviceTemplateId: string;
    };
    query?: {
        /**
         * type of service template request
         */
        requestType?: ServiceTemplateRequestType;
        /**
         * status of service template request
         */
        requestStatus?: ServiceTemplateRequestStatus;
    };
    url: '/xpanse/csp/service_templates/{serviceTemplateId}/requests';
};

export type GetServiceTemplateRequestHistoryForCspErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetServiceTemplateRequestHistoryForCspError =
    GetServiceTemplateRequestHistoryForCspErrors[keyof GetServiceTemplateRequestHistoryForCspErrors];

export type GetServiceTemplateRequestHistoryForCspResponses = {
    /**
     * OK
     */
    200: Array<ServiceTemplateRequestHistory>;
};

export type GetServiceTemplateRequestHistoryForCspResponse =
    GetServiceTemplateRequestHistoryForCspResponses[keyof GetServiceTemplateRequestHistoryForCspResponses];

export type GetPendingServiceReviewRequestsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * id of service template
         */
        serviceTemplateId?: string;
    };
    url: '/xpanse/csp/service_templates/requests/pending';
};

export type GetPendingServiceReviewRequestsErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetPendingServiceReviewRequestsError =
    GetPendingServiceReviewRequestsErrors[keyof GetPendingServiceReviewRequestsErrors];

export type GetPendingServiceReviewRequestsResponses = {
    /**
     * OK
     */
    200: Array<ServiceTemplateRequestToReview>;
};

export type GetPendingServiceReviewRequestsResponse =
    GetPendingServiceReviewRequestsResponses[keyof GetPendingServiceReviewRequestsResponses];

export type GetExistingResourceNamesWithKindData = {
    body?: never;
    path: {
        /**
         * kind of the CloudResource
         */
        deployResourceKind: DeployResourceKind;
    };
    query: {
        /**
         * name of the cloud service provider
         */
        csp: Csp;
        /**
         * the site of the service belongs to
         */
        siteName: string;
        /**
         * name of the region
         */
        regionName: string;
        /**
         * id of the deployed service
         */
        serviceId?: string;
    };
    url: '/xpanse/csp/resources/{deployResourceKind}';
};

export type GetExistingResourceNamesWithKindErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetExistingResourceNamesWithKindError =
    GetExistingResourceNamesWithKindErrors[keyof GetExistingResourceNamesWithKindErrors];

export type GetExistingResourceNamesWithKindResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type GetExistingResourceNamesWithKindResponse =
    GetExistingResourceNamesWithKindResponses[keyof GetExistingResourceNamesWithKindResponses];

export type GetAvailabilityZonesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * name of the cloud service provider
         */
        cspName: Csp;
        /**
         * site of the region belongs to
         */
        siteName: string;
        /**
         * name of the region
         */
        regionName: string;
        /**
         * Id of the serviceTemplate
         */
        serviceTemplateId?: string;
        /**
         * Id of the deployed service
         */
        serviceId?: string;
    };
    url: '/xpanse/csp/region/azs';
};

export type GetAvailabilityZonesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAvailabilityZonesError = GetAvailabilityZonesErrors[keyof GetAvailabilityZonesErrors];

export type GetAvailabilityZonesResponses = {
    /**
     * OK
     */
    200: Array<string>;
};

export type GetAvailabilityZonesResponse = GetAvailabilityZonesResponses[keyof GetAvailabilityZonesResponses];

export type GetCredentialOpenApiData = {
    body?: never;
    path: {
        /**
         * The cloud service provider.
         */
        csp: Csp;
        /**
         * The type of credential.
         */
        type: CredentialType;
    };
    query?: never;
    url: '/xpanse/credentials/openapi/{csp}/{type}';
};

export type GetCredentialOpenApiErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetCredentialOpenApiError = GetCredentialOpenApiErrors[keyof GetCredentialOpenApiErrors];

export type GetCredentialOpenApiResponses = {
    /**
     * OK
     */
    200: Link;
};

export type GetCredentialOpenApiResponse = GetCredentialOpenApiResponses[keyof GetCredentialOpenApiResponses];

export type GetCredentialCapabilitiesData = {
    body?: never;
    path?: never;
    query: {
        /**
         * name of the cloud service provider.
         */
        cspName: Csp;
        /**
         * The type of credential.
         */
        type?: CredentialType;
        /**
         * The name of credential.
         */
        name?: string;
    };
    url: '/xpanse/credentials/capabilities';
};

export type GetCredentialCapabilitiesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetCredentialCapabilitiesError = GetCredentialCapabilitiesErrors[keyof GetCredentialCapabilitiesErrors];

export type GetCredentialCapabilitiesResponses = {
    /**
     * OK
     */
    200: Array<AbstractCredentialInfo>;
};

export type GetCredentialCapabilitiesResponse =
    GetCredentialCapabilitiesResponses[keyof GetCredentialCapabilitiesResponses];

export type GetCredentialTypesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The cloud service provider.
         */
        cspName?: Csp;
    };
    url: '/xpanse/credential_types';
};

export type GetCredentialTypesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetCredentialTypesError = GetCredentialTypesErrors[keyof GetCredentialTypesErrors];

export type GetCredentialTypesResponses = {
    /**
     * OK
     */
    200: Array<CredentialType>;
};

export type GetCredentialTypesResponse = GetCredentialTypesResponses[keyof GetCredentialTypesResponses];

export type GetOrderableServicesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * category of the service
         */
        categoryName?: Category;
        /**
         * name of the cloud service provider
         */
        cspName?: Csp;
        /**
         * name of the service
         */
        serviceName?: string;
        /**
         * version of the service
         */
        serviceVersion?: string;
        /**
         * who hosts ths cloud resources
         */
        serviceHostingType?: ServiceHostingType;
    };
    url: '/xpanse/catalog/services';
};

export type GetOrderableServicesErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetOrderableServicesError = GetOrderableServicesErrors[keyof GetOrderableServicesErrors];

export type GetOrderableServicesResponses = {
    /**
     * OK
     */
    200: Array<UserOrderableServiceVo>;
};

export type GetOrderableServicesResponse = GetOrderableServicesResponses[keyof GetOrderableServicesResponses];

export type GetOrderableServiceDetailsByIdData = {
    body?: never;
    path: {
        /**
         * The id of orderable service.
         */
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/catalog/services/{serviceTemplateId}';
};

export type GetOrderableServiceDetailsByIdErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetOrderableServiceDetailsByIdError =
    GetOrderableServiceDetailsByIdErrors[keyof GetOrderableServiceDetailsByIdErrors];

export type GetOrderableServiceDetailsByIdResponses = {
    /**
     * OK
     */
    200: UserOrderableServiceVo;
};

export type GetOrderableServiceDetailsByIdResponse =
    GetOrderableServiceDetailsByIdResponses[keyof GetOrderableServiceDetailsByIdResponses];

export type OpenApiData = {
    body?: never;
    path: {
        serviceTemplateId: string;
    };
    query?: never;
    url: '/xpanse/catalog/services/{serviceTemplateId}/openapi';
};

export type OpenApiErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type OpenApiError = OpenApiErrors[keyof OpenApiErrors];

export type OpenApiResponses = {
    /**
     * OK
     */
    200: Link;
};

export type OpenApiResponse = OpenApiResponses[keyof OpenApiResponses];

export type GetAccessTokenData = {
    body?: never;
    path?: never;
    query: {
        /**
         * The authorization code.
         */
        code: string;
        /**
         * Opaque value used to maintain state.
         */
        state: string;
    };
    url: '/auth/token';
};

export type GetAccessTokenErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetAccessTokenError = GetAccessTokenErrors[keyof GetAccessTokenErrors];

export type GetAccessTokenResponses = {
    /**
     * OK
     */
    200: TokenResponse;
};

export type GetAccessTokenResponse = GetAccessTokenResponses[keyof GetAccessTokenResponses];

export type AuthorizeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/authorize';
};

export type AuthorizeErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type AuthorizeError = AuthorizeErrors[keyof AuthorizeErrors];

export type AuthorizeResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type GetPendingServiceChangeRequestData = {
    body?: never;
    path: {
        /**
         * The id of the deployed service
         */
        serviceId: string;
        /**
         * The name of the resource of deployed service
         */
        resourceName: string;
    };
    query?: never;
    url: '/agent/xpanse/poll/{serviceId}/{resourceName}';
};

export type GetPendingServiceChangeRequestErrors = {
    /**
     * Bad Request
     */
    400: ErrorResponse;
    /**
     * Unauthorized
     */
    401: ErrorResponse;
    /**
     * Forbidden
     */
    403: ErrorResponse;
    /**
     * Request Timeout
     */
    408: ErrorResponse;
    /**
     * Unprocessable Entity
     */
    422: ErrorResponse;
    /**
     * Internal Server Error
     */
    500: ErrorResponse;
    /**
     * Bad Gateway
     */
    502: ErrorResponse;
};

export type GetPendingServiceChangeRequestError =
    GetPendingServiceChangeRequestErrors[keyof GetPendingServiceChangeRequestErrors];

export type GetPendingServiceChangeRequestResponses = {
    /**
     * pending service change update request details
     */
    200: ServiceChangeRequest;
    /**
     * no pending service change update requests
     */
    204: void;
};

export type GetPendingServiceChangeRequestResponse =
    GetPendingServiceChangeRequestResponses[keyof GetPendingServiceChangeRequestResponses];

export type DestroyData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/{serviceId}';
};

export type DestroyErrors = {
    400: OrderFailedErrorResponse;
    401: OrderFailedErrorResponse;
    403: OrderFailedErrorResponse;
    408: OrderFailedErrorResponse;
    422: OrderFailedErrorResponse;
    500: OrderFailedErrorResponse;
    502: OrderFailedErrorResponse;
};

export type DestroyError = DestroyErrors[keyof DestroyErrors];

export type DestroyResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type DestroyResponse = DestroyResponses[keyof DestroyResponses];

export type PurgeData = {
    body?: never;
    path: {
        /**
         * Id of the service
         */
        serviceId: string;
    };
    query?: never;
    url: '/xpanse/services/purge/{serviceId}';
};

export type PurgeErrors = {
    400: OrderFailedErrorResponse;
    401: OrderFailedErrorResponse;
    403: OrderFailedErrorResponse;
    408: OrderFailedErrorResponse;
    422: OrderFailedErrorResponse;
    500: OrderFailedErrorResponse;
    502: OrderFailedErrorResponse;
};

export type PurgeError = PurgeErrors[keyof PurgeErrors];

export type PurgeResponses = {
    /**
     * Accepted
     */
    202: ServiceOrder;
};

export type PurgeResponse = PurgeResponses[keyof PurgeResponses];
